<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VirtualBeingsTech</name>
    </assembly>
    <members>
        <member name="T:VirtualBeings.ActiveCognition.IEatTrackerSettings">
            <summary>
            Should be implemented by the being settings
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.ISmellTrackerSettings">
            <summary>
            Should be implemented by the being settings
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.BeingSettings">
            <summary>
            This abstract class contains non-shared settings for all types of beings. Its concrete subclasses are specific to cats, birds etc.
            NB: This class used to be called 'ImmutableBeingData' (and still is in a lot of Unity-side code in some projects)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.BeingSettings.InitializeAnimationStateBase">
            <summary>
            Ensure that all static classes are properly initialized for use by KuteEngine. Necessary because use of
            the static supertype of a static class obviously doesnt initialize fields that are 'meant' to be set by the subtype.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.BeingSettings.MotiveSettings">
            Data that is solely used in the context of being spawning.
            Also it is data that never changes and therefore not serialized/deserialized across different game sessions.
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Cog.Init">
            <summary>
            Override to initialize Cog after static Create has been called. This happens only once during
            a game session (while the VB exits), as unused Cogs are stored for reuse.
            NB: DictCogDependencies has been initialized when this is called, but do *not* assume
            that members also had their Init methods called
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Cog.OnUse(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Called when a cog gets used from activity 'user' which doesnt use it yet
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Cog.OnRelease(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Called when a cog is released from activity 'user'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Cog.OnActivate">
            <summary>
            Called when an activity requests a currently unused Cog via Use
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Cog.OnDeactivate">
            <summary>
            Called when a cog has been released by all activities
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Gear.CreateGear(System.Type)">
            <summary>
            Create an instance of a Specific Gear with the given type.
            The gear is not initialized.
            </summary>
            <param name="gearSubType"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.BeingData">
            <summary>
            Contains data per instance of beings. All the data retain information about the being instance, even on different game sessions.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.BeingData.TimeInSecondsUntilEarliestNextSpawn">
            <summary>
            Real time at which the being can either spawn again or create a visit.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.BeingData.EnsureInitialized(System.Int32,System.Boolean@)">
            <summary>
            BeingData is per being, but should be initialized only once per session.
            Meaning a Being, when first spawned, should have its BeingData initialized. But when despawned and then respawn, this is not necessary.
            </summary>
            <param name="nMotives"></param>
            <param name="initWasNecessary"></param>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.BeingData.BMI">
            <summary>
            Range 10 to 50
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Motive">
            <summary>
            Motives here can be compared to Panksepp's primal emotions. For the AI, each motive furnishes a value
            which can inform decision making. The value automatically or manually increases/decreases
            over time (this is decided by the current activity, or by default by the Mind, which will
            apply automatic time-based changes).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.ResetSatisfactionPoint(System.Boolean)">
            <summary>
            If SatisfactionPoint was changed procedurally, use this to reset it to its default value
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.Reset(System.Single)">
            <summary>
            Does what it says.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Motive.Salience01">
            <summary>
            Shortcut to BeingSettings.MotiveSaliences01[MotiveIndex]
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Motive.Satisfaction">
            <summary>
            Has a range of [0..1], with 0f meaning 'not satisfied'.
            It is 1f if Value01 is 1f and 0f if Value01 is at or below SatisfactionPoint.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Motive.Dissatisfaction">
            <summary>
            Has a range of [0..1], with 0f meaning 'satisfied'.
            It is 1f if Value01 is 0f and 0f if Value01 is at or above SatisfactionPoint.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Motive.TimeOfLastUpdate">
            <summary>
            When this motive's Value01 was last recalculated
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.ApplyDirectChange(System.Single,System.Boolean)">
            <summary>
            Can be called from anywhere, e.g. 'motive changer' methods inside activities (including Mind)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.SetDurationUntilSatisfied(System.Single)">
            <summary>
            NB: this method changes primarily SatisfactionPoint and in some cases reduces Value01
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.SetNIncrementsUntilSatisfied(System.Int32,System.Single)">
            <summary>
            NB: this method changes primarily SatisfactionPoint and in some cases reduces Value01
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.SetDeltaUntilSatisfied(System.Single)">
            <summary>
            NB: this method changes primarily SatisfactionPoint and in some cases reduces Value01
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.EnsureSatisfied(System.Single,System.Boolean)">
            <summary>
            Sets the motive Value01 to at least the following via Lerp:
              'SatisfactionPoint' if satisfied01 == 0,
              1 if satisfied01 == 1,
            </summary>
            <param name="satisfied01"></param>
            <param name="sendUpdateMessage">NB: if true, triggers a call to Mind.ReprioritizeRootActivity().
            Will therefore result in infinite loop if set inside the CalculatePriority() call order</param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.EnsureDissatisfied(System.Single,System.Boolean)">
            <summary>
            Ensures Value01 is no higher than:
              'SatisfactionPoint' if dissatisfied01 is 0,
              0 if dissatisfied01 is 1.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.UnBind(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Called automatically when bindingActivity exits; can be called manually if unbind has to happen earlier
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.TriggerTimeBasedChange">
            <summary>
            Called only from Mind.UpdateMotives()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.#ctor(VirtualBeings.Tech.ActiveCognition.Mind,VirtualBeings.Tech.ActiveCognition.MotiveName,System.Boolean,System.Single,System.Single)">
            <summary>
            How is the Value01 of a motive initialized upon instantiation? Simple:
            - If cat was 'very recently' uninstantiated, just use the serialized values.
            - If motive is not auto-depleting or 'unimportant' for this being, set to 1f.
            - Otherwise, randomize between a low and a high value. If motive is 'important',
              ensure that the high value is still below SatisfactionPoint.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Motive.Bind(VirtualBeings.Tech.BehaviorComposition.Process,System.Single,System.Boolean)">
            <summary>
            Called internally via BindAutoDecrease/Increase
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.GetCog``1">
            <summary>
            Get a singleton Cog without calling its Use method
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.TryGetGear``1">
            <summary>
            Try to get a Gear of the corresponding type. Can be null if not Gear found.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.OnMotiveUpdated(VirtualBeings.Tech.ActiveCognition.Motive)">
            <summary>
            Called from either Motive after a motive was updated; it's corresponding IRootActivity
            now needs to be removed and re-inserted into the PQ for root activities
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.ReprioritizeRootActivity(VirtualBeings.Tech.BehaviorComposition.IRootActivity)">
            <summary>
            Called internally or externally to reevaluate the priority of rootActivity
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.GetCog(System.Type)">
            <summary>
            Internal version of GetCog(T)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.TryGetGear(System.Type)">
            <summary>
            Try to get a Gear based on the given type. Can return null if not found.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.UseCog``1">
            <summary>
            Get Cog *and* use it right away. Should only be called from descendents of Mind; all other activities should use the
            UseCog method provided in their [BeingType]Activity superclass.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.#ctor(VirtualBeings.Tech.BehaviorComposition.Being)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mind.InitializeGears">
            <summary>
            Create and initialize all gears that the being should have.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.TrackedInteractable">
            <summary>
            Class that gives access to IInteractables tracked by various gears
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedInteractable.TimeOfLastInteraction">
            <summary>
            Handled by activities
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedInteractable.UpdateInteractiveHabituation(System.Single)">
            <summary>
            Simply dampens InteractiveHabituation01 up using DampTimeInteractiveHabituation.
            This must be called by Activities.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedInteractable.MarkAsNewInFOV">
            <summary>
            Only called by FOVTracker (when Interactable re/enters in FOV)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedInteractable.UpdateDependentVariables(System.Single)">
            <summary>
            Only called by FOVTracker (when Interactable is already in FOV)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedInteractable.SetTimeOfLastFOVExit(System.Single)">
            <summary>
            All setters only called by FOVTracker
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.Source">
            <summary>
            Who is threatening? Never null.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.Reason">
            <summary>
            Why is Source threatening?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.MaxThreat01">
            <summary>
            How threatening is/was this threat while it was active?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.IntrinsicThreat01">
            <summary>
            How threatening is this threat 'intrinsically' (not due to its motion alone)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.Threat01">
            <summary>
            How threatening is this threat right now?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.MostRecentActiveTime">
            <summary>
            Most recent time Source was identified as threatening
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.MostRecentDeactivationTime">
            <summary>
            Most recent time threat by Source became inactive
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.IsActive">
            <summary>
            Is threat currently (still) active?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Threat.Age">
            <summary>
            How long ago did this threat become a new threat? (0 means it is inactive)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Threat.SetInactive">
            <summary>
            Mark threat as inactive or 'handled'.
            NB: threats *have* to be set inactive manually by clients, it's never done automatically.
            This is their way of saying that this threat has been dealt with.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Self">
            <summary>
            A "Self" contains the motives of the being
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Self.Motives">
            public interface
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Self.AcquiredTrustInMainPlayer01">
            <summary>
            A food appreciator is someone who at least enjoys eating (EAT salience is above average)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Self.GetDesirability01(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Returns personality-based preferences for certain toys, treats etc.
            TODO for the future, apply habituation over time (within and across play sessions).
                Use InteractableProperty in combo with Dict to store this info.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Self.GetDesirability01(System.Int32)">
            <summary>
            See GetDesirability01(IInteractable)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector">
            <summary>
            All PathInspector objects are reusable.
            </summary>
            <summary>
            All PathInspector objects are reusable.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector.SucceedWhenCloseToEnd">
            <summary>
            A Strategy which succeeds pathfinding when search has gotten sufficiently close
            (linear distance) to end.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector.KeepTrackOfBestLeavesOfSearchTree">
            <summary>
            An abstract strategy that uses a dictionary and a priority queue to keep track of
            the 'best' PathNode among all those that currently constitute leafs in the search tree
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.KeepTrackOfBestLeavesOfSearchTree.UpdateDataOnBestPathNode(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,System.Double)">
            <summary>
            Subclasses can use this in VisitAndCheckIfComplete() to keep track of the hitherto
            best PathNode (the one with the lowest f-score)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector.KeepTrackOfNodeClosestToEnd">
            <summary>
            An abstract strategy that uses a single variable to keep track of the node that so far is closest to the end
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector.StayWithinSectorORCircle">
            <summary>
            A Strategy which confines search to only those nodes whose symedges are (partially) inside
            the sector of 'sectorAngle' degrees around the vector from start to goal, "OR" (logically!) the circle of radius
            'radius' around start (or both). Succeeds with the hitherto best partial path when search is exhausted.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.StayWithinSectorORCircle.#ctor(System.Double,System.Double)">
            <summary>
            Set either sectorAngleInRadians or radius to 0 if you dont want it to be used.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PathInspector.StayWithinSectorANDCircle">
            <summary>
            A Strategy which confines search to only those nodes whose symedges are (partially) inside
            the sector of 'sectorAngle' degrees around the vector from start to goal, "AND" (logically!) the circle of radius
            'radius' around start (or both). Succeeds with the hitherto best partial path when search is exhausted.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.StayWithinSectorANDCircle.#ctor(System.Double,System.Double)">
            <summary>
            Set either sectorAngleInRadians or radius to 0 if you dont want it to be used.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.PathInspector.Default">
            <summary>
            Return the default (singleton) instance of this class, with minimal/shell functionality.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.VisitAndCheckIfComplete(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode)">
            <summary>
            Override this to check if a pathnode is good (enough), returning true will make RSBF stop immediately.
            IMPORTANT: before returning true, overriding methods MUST call SetNewGoal() with a point inside the node! 
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.IsTraversible(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Override this to block RSBF to explore a node any further
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.GetBestPathNode">
            <summary>
            Override this to allow RSBF to return a 'suboptimal' node. If null is returned, RSBF will return an empty list of corners
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.SetNewGoal(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Change the goal (i.e., the vertex of the final corner that will be returned from a successful RSBF)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.Init(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.Dictionary{VirtualBeings.Tech.ActiveCognition.Face,VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode},System.Double)">
            <summary>
            Initialization method that must be called from subclasses
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PathInspector.ExtractCorners(System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,VirtualBeings.Tech.ActiveCognition.Symedge@)">
            <summary>
            Extract list of corners into lResultBuffer and return the 'blocking Symedge'
            (see RS-BF for details on this).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.BeingSharedSettings">
            <summary>
            Contains settings that apply to all beings of the same species. This abstract superclass contains fields that
            are relevant to all species, whereas concrete subclasses are specific to all cats, all birds etc in a project.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.BeingSharedSettings.BestDistRootToMouthOnXZ">
            <summary>
            Measured from root
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.BeingSharedSettings.FactorForObstacleAvoidance">
            Behaviors
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.DistressObserver">
            <summary>
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DistressObserver.MostRecentUndistressedPosition">
            public interface
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DistressObserver.DistressResponderIsActive">
            <summary>
            Toggled by DistressResponder RA
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DistressObserver.IsBlockedFromBeing(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Use 2D pathfinding to see if an object is unreachable via 2D locomotion
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DistressObserver.Tick">
            internals
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.RelationshipTracker">
            <summary>
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.RelationshipTracker.Relationships">
            public interface
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.RelationshipTracker.InitSpecific">
            internals
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.RelationshipTracker.SetRelationship(VirtualBeings.Tech.BehaviorComposition.Being,System.Boolean)">
            <summary>
            Only called here or by CatBeing
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Communicator">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Communicator.HasReceivedCommunicativeAct(VirtualBeings.Tech.BehaviorComposition.Being,VirtualBeings.Tech.UnityIntegration.CommunicativeAct,System.Int32)">
            public interface
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Communicator.PostCommunicativeActToOther(VirtualBeings.Tech.BehaviorComposition.Being,VirtualBeings.Tech.UnityIntegration.CommunicativeAct)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Communicator.InitSpecific">
            internals
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.InteractionTracker">
            <summary>
            This gear keeps track of interaction-mode interactions that this agent has or is participating in.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractionTracker.OnStartInteraction(VirtualBeings.Tech.UnityIntegration.WorldEvent_InteractionModeStarted)">
            <summary>
            TODO in the future, make call to gamemanager (probably *asynchronously* via callbacks):
            - to decide IF gamemanager *recommends* this agent participate in the interaction (rather than some other agent)
            - to request THAT the agent participate, and let the agent know HOW (in what role)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.ThreatTracker">
            <summary>
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.ThreatTracker.HasActiveThreat">
            public interface
            <summary>
            Are there any active threats at all?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.ThreatTracker.MostRecentThreat">
            <summary>
            Returns an active threat, or null
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.SetCurrentThreshold(System.Single)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.GetWorstAndClosestThreats(VirtualBeings.Tech.ActiveCognition.Threat@,VirtualBeings.Tech.ActiveCognition.Threat@,System.Int32)">
            <summary>
            Retrieves the worst and closest active threats (or null for both)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.WorstThreat(System.Int32)">
            <summary>
            Returns the worst active threat, or null
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.ClosestThreat(System.Int32)">
            <summary>
            Returns the closest active threat, or null
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.Clean(System.Int32)">
            <summary>
            Deactivates active threats that are below current threat threshold
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.GetThreat(VirtualBeings.Tech.ActiveCognition.TrackedInteractable)">
            <summary>
            Get the Threat object (or null) for a TrackedInteractable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.ThreatTracker.ListActiveThreats">
            <summary>
            Linked list of all currently active threats
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.ConditionallyTrust(VirtualBeings.Tech.BehaviorComposition.Activity,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Func{VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean})">
            <summary>
            Allow an activity to signal that the being 'trusts' (=isn't threatened by) trustee if isTrustworthy is true.
            Note that in that case, trustee will not be tracked (and also untracked) as a threat - for the entire being.
            This trust is automatically revoked when the activity exists.
            NB: if trustee is an active threat it is deactivated right away.
            </summary>
            <param name="trustor"></param>
            <param name="trustee"></param>
            <param name="isTrustworthy">Can be null, in that case the trustee is always trustworthy</param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.UnTrust(VirtualBeings.Tech.BehaviorComposition.Activity,VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Revoke 'trust' in an interactable *manually*.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.PostThreat(VirtualBeings.Tech.ActiveCognition.Threat.ReasonOfThreat,VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean,System.Single)">
            internals
            <summary>
            NB: works even if 'source' is already posing a threat; in this case 'reason' will be updated.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.SetInactive(VirtualBeings.Tech.ActiveCognition.TrackedInteractable)">
            <summary>
            A threatening interactable is deactivated by setting MostRecentDeactivation to current time
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.ThreatTracker.IsThreateninglyClose(VirtualBeings.Tech.ActiveCognition.TrackedInteractable)">
            <summary>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.TrackedEventDB">
            <summary>
            NB: each interactable can only be associated with a single event (currently a sound or a movement event).
            If it's the focus of a new event, any associated previous event will be forgotten.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.DistractingEvent">
            Public interface
            <summary>
            Most recently attended-to distracting event; written and read freely by anyone because it is a shared resource.
            Setting it to a new value fires a AgentEvent_DistractionChanged
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.LastIngestionEvent">
            <summary>
            Most recent ingestion event
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.FindFirst(System.Func{VirtualBeings.Tech.UnityIntegration.AgentEvent_Salient,System.Boolean},System.Single,System.Boolean,System.Single,System.Int32)">
            <summary>
            Linear, ordered search over all events for the first one that satisfies a custom predicate.
            Events are visited in the order of their last entry into the DB (most recent first).
            NB: predicate can be null (in which case it's always true)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.FindBest(System.Single,System.Boolean,System.Single,System.Single,System.Int32)">
            <summary>
            Bounded search over all events for the one with the highest salience, but search also ends when thresholdSalience01 is reached/crossed.
            Events are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.FindBest(System.Func{VirtualBeings.Tech.UnityIntegration.AgentEvent_Salient,System.Single},System.Single,System.Boolean,System.Single,System.Int32)">
            <summary>
            Bounded search over all events for the one with the highest value returned by evaluator.
            Events are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.CurrentEventIntensity01">
            <summary>
            Measure of how many events (weighted by their salience) are happening in succession at the moment
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.CurrentEventMidpoint">
            <summary>
            Where is the weighted mid-point of recent events? This moves more slowly when event intensity is high
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TrackedEventDB.CurrentAverageSpread">
            <summary>
            The average, damped distance of recent events from the event midpoint
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.FOVTracker">
            <summary>
            This gear has no interface, it only tracks visible Interactables (posting them to InteractableMemory) when they enter or leave the FOV.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.FOVTracker.Tick">
            internals
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.FOVTracker.UpdateRelevanceVariables(VirtualBeings.Tech.ActiveCognition.TrackedInteractable)">
            <summary>
            Apply heuristics to determine *how* interesting/invasive/threatening an object currently is
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.PlayerTracker">
            <summary>
            This gear provides services to keep track of players.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.PlayerTracker.Players">
            <summary>
            NB: theoretically this list may now be empty (e.g. if the game is run on a headless server without players)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PlayerTracker.SetMainPlayer(VirtualBeings.Tech.UnityIntegration.PlayerAgent)">
            <summary>
            Pragmatic solution to allow a being to focus on different players:
            allow users to set MainPlayer to a new IAgent
            </summary>
            <param name="newMainPlayer"></param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PlayerTracker.MakeMainPlayerLocal(System.Boolean)">
            <summary>
            Ensure that MainPlayer points to a random local player
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PlayerTracker.RandomizeMainPlayer(System.Boolean)">
            <summary>
            Pragmatic solution to allow a being to focus on different players:
            keep the MainPlayer property but allow randomizing what it refers to
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.PlayerTracker.GetGroundPosOfBestVisibility(VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain)">
            <summary>
            Returns a point on the ground that's in the lower middle part of
            player's FOV (but forced to be inside player area)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.SoundTracker">
            <summary>
            This gear interprets world events of type WorldEvent_Sound and posts them to SalientEventTrackerGear.
            It is not usable directly by ABs (activities or behaviors)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.TouchTracker">
            <summary>
            Gear that aggregates touch data:
            - about current touch
            - about currently and recently touched body parts
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TouchTracker.MarkTouchResponse(System.Boolean)">
            <summary>
            Notify gear that an activity is responding positively/antagonistically to touch
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TouchTracker.MostRecentResponsibleAgent">
            <summary>
            Which agent caused the most recent touch / hit / poke? (Can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TouchTracker.MostRecentSourceInteractable">
            <summary>
            Which interactable touched / hit / poked being? (Never null if being has been impacted once)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.TouchTracker.ThresholdAnnoyance">
            <summary>
            The maximum annoyance below which the agent should somehow 'handle' it
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TouchTracker.Annoyance01">
            <summary>
            Aggregate assessment of how 'annoyed' the agent is regarding how it's being touched.
            Annoyance01 is a responsive value, it changes over seconds.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TouchTracker.GlobalTouchPleasure">
            <summary>
            Complementary to Annoyance01, this has range [-1..1] and indicates how globally dis/satisfied
            the being is from touch.
            For the most part it changes slowly. Only changes rapidly upon very unpleasant forms of touch.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.TouchTracker.DestroyGlobalTouchPleasure">
            <summary>
            TODO feels like a hack, better coordinate with Annoyance and/or with MarkTouchResponse(false)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.TouchTracker.CumulativeTouchIntensity">
            <summary>
            Simple damped cumulator that measures how much the being is being touched, over time
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.ITouchTrackerSettings">
            <summary>
            Should be implemented by the being settings
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.TouchTrackerSettings.TouchReactionInfo">
             <summary>
             How to understand TouchEnjoyment01 and SensitivityThreshold01:
            
             TouchEnjoyment01 indicates how much this being *likes* being touched on this spot:
                 0-.09 is deep dislike (antagonism)
                .1-.29 is urgent dislike/ticklishness (resulting in an event)
                .3-.39 is non-urgent dislike (not resulting in an event, but has consequences such as: purr stops, less relaxed)
                .4-.59 is 'basic' enjoyment
                .6-.69 is stronger preference (causes purr)
                .7-.89 is even stronger preference (meaning...? TODO)
                .9-1 is favorite spot
            
             SensitivityThreshold01 indicates how *quickly* being reacts in a negative/positive way. Lower means faster.
             The higher the threshold, the longer the touch needs to 'build up' to cause a reaction.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.InteractableMemory">
            <summary>
            Main function of this gear: it tracks interactables as soon as they appear in the FOV,
            and then until they are destroyed.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.IsInFOV(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            public interface
            <summary>
            Is interactable being tracked, and is it currently in FOV?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.MostRecent(VirtualBeings.Tech.UnityIntegration.InteractableProperty)">
            <summary>
            Return most recently found/updated TrackedInteractable with a given property. O(1)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindFirst(System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean},System.Int32)">
            <summary>
            Linear, ordered search over all interactables for the first one that satisfies a custom predicate.
            Interactables are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindFirst(VirtualBeings.Tech.UnityIntegration.InteractableProperty,System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean},System.Int32)">
            <summary>
            Linear, ordered search over all interactables with a given property for the first one that satisfies a custom predicate.
            Interactables are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindBest(System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Single},System.Int32)">
            <summary>
            Bounded search over all interactables for the one with the highest value returned by evaluator.
            Interactables are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindBest(VirtualBeings.Tech.UnityIntegration.InteractableProperty,System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Single},System.Int32)">
            <summary>
            Bounded search over all interactables with a given property for the one with the highest value returned by evaluator.
            Interactables are visited in the order of their last entry into the DB (most recent first).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.RegisterCallback(VirtualBeings.Tech.BehaviorComposition.Activity,System.Action{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean})">
            <summary>
            Use this to get notified when an Interactable gets updated (because it enters, remains in, or leaves the FOV)
            NB: only one callback per Activity will be stored, and unregistering is automatic.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.UnregisterCallback(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Unregister callback that has been registered by owner
            NB: done automatically when owner exits
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.TryGetTracked(VirtualBeings.Tech.UnityIntegration.IInteractable,VirtualBeings.Tech.ActiveCognition.TrackedInteractable@)">
            Public interface for other Gears/Cogs
            <summary>
            Get a TrackedInteractable for an interactable that's already tracked.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.Track(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            This method ensures that interactable will be tracked and also (if necessary) deletes and reinserts its
            tracking data, so that it is now the most recent entry
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.MarkUpdated(VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean,System.Boolean)">
            <summary>
            Only called by FOVTracker, gives using activities a chance to inspect the (re-)tracked interactable
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindFirstInternal(System.Collections.Generic.LinkedListNode{VirtualBeings.Tech.ActiveCognition.TrackedInteractable},System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Boolean},System.Int32)">
            Internals
            <summary>
            Used by Find() methods above; current may be null
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.InteractableMemory.FindBestInternal(System.Collections.Generic.LinkedListNode{VirtualBeings.Tech.ActiveCognition.TrackedInteractable},System.Func{VirtualBeings.Tech.ActiveCognition.TrackedInteractable,System.Single},System.Int32)">
            <summary>
            Used by Find() methods above; bestSoFar must be non-null
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation">
            <summary>
            The main class of this project. It represents a "dynamically constrained Delaunay triangulation" (DCDT).
            It is based on publications by Prof. Marcelo Kallmann, University of California at Merced, and his
            colleagues. See especially the following two papers:
              Kallmann et al., Fully Dynamic Constrained Delaunay Triangulations, 2003 (on the DCDT)
              Kallmann, Navigation Queries from Triangular Meshes, 2010 (on the Symedge datastructure)
            
            The main point of the DCDT is to represent a navigation mesh (navmesh) that:
            - is *tight* (there is no space between obstacles and the mesh, as in almost all other navmeshes),
            - is dynamic (obstacles, i.e., 'constraints', can be added and removed efficiently at run-time; movement
              of constraints is simulated as removal/reinsertion at the desired frequency),
            - supports efficient path-finding: because all edges in the DCDT are either constrained or fulfill the
              Delaunay property, triangles with very small angles are rare. Paths can be extracted efficiently
              with rubber-string best-first search (RS-BF).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.Mesh">
            <summary>
            See Mesh.cs - the mesh class encapsulates all changes to the navmesh used here.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation._lConstraints">
            <summary>
            The DCDT keeps a list of the polyline-constraints that have been inserted.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.BoundingBox">
            <summary>
            The bounding box of the navmesh. Created during construction; can never be deleted or changed.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.BoundaryConstraintID">
            <summary>
            The ID of the constraint that represents the bounding box of the navmesh.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.Epsilon">
            <summary>
            Epsilon determines the threshold in distance between two points below which they are
            considered indistinct. A larger value will result in more greatly deformed constraints
            (but also in a navmesh with fewer elements and fewer small triangles).
            NB: I have not tested what happens when you change Epsilon after initialization. Don't do it.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.LastTriangulationFace">
            <summary>
            Used internally during vertex insertion.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.HasConstraint(System.Int32)">
            <summary>
            Check if a constraint with id 'constraint_id' exists in the DCDT.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.UseEventSystem">
            <summary>
            Flag which de-/activates the face-change broadcasting system.
            TODO before using the event system, make sure that it uses object pooling.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.OnDCDTChanged(System.EventArgs)">
            <summary>
            The following method and event constitute the mechanism for broadcasting
            information about macro-changes to the DCDT (insertion/deletion of contraints).
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.DCDTChanged">
            <summary>
            Subscribe to this event to be notified about global changes in the DCDT
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.CheckBoundingBox(VirtualBeings.Tech.Utils.PolyLine,System.Boolean@)">
            <summary>
            Used internally to check if bb is a convex quadrilateral. The four points p0..p3 define 
            such a quadrilateral if p2 is on the same side of p0->p1 as p3 is of p1->p2.
            
            The bounding box should always be set by hand; hence, this function does not check for numerically
            degenerate cases.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InitializeDCDT(VirtualBeings.Tech.Utils.PolyLine,System.Double,System.Collections.Generic.Dictionary{System.Int32,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.ActiveCognition.Edge}})">
            <summary>
            Initialize the LC-Triangulation with a bounding box and an outer perimeter, which will be
            inserted and triangulated (by simply inserting diagonals).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.#ctor(VirtualBeings.Tech.Utils.PolyLine,System.Double)">
            <summary>
            The constructor relies mostly on InitializeDCDT().
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.ResetDCDT">
            <summary>
            Reset the DCDT to the initial state (before any constraints were inserted)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.ResetEvents">
            <summary>
            Clear all DCDT events (and those of dependent classes) from subscribers.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.DeleteAndReinsertPolyline(VirtualBeings.Tech.Utils.PolyLine,System.Boolean,System.Int32)">
            <summary>
            Use this method if you want to move a constraint to a new position. It simply chains
            DeletePolyline() and InsertPolyline(), so see the documentation for those methods.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InsertPolyLine(VirtualBeings.Tech.Utils.PolyLine,System.Boolean,System.Int32)">
            <summary>
            Insert a set of line constraints into the triangulation.
            Begin by inserting points and triangulating, then insert lines to make
            sure they are part of the triangulation.
            
            We now allow insertion of both polylines and collections of segments via a parameter. For simplicity's sake,
            the latter also use the PolyLine class, but they must contain an even number of points, and only the odd
            pairs are assumed to be line segments).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InsertSegment(VirtualBeings.Tech.ActiveCognition.Vertex,VirtualBeings.Tech.ActiveCognition.Vertex,System.Int32)">
            <summary>
            Insert a single line-constraint into the triangulation; the endpoints p1 and p2 must already
            exist within the mesh. Note that segment insertion may result in additional vertices (i.e.,
            whenever it is found that the current segment intersects within an existing segment.
            Also, no segment will be inserted if the distance between p1 and p2 is smaller than Epsilon.
            </summary>
            <returns>List of edges that were actually inserted; together, they will form a polyline
            from p1 to p2.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.GetInitialTriangleForSegmentInsertion(VirtualBeings.Tech.ActiveCognition.Vertex,VirtualBeings.Tech.ActiveCognition.Vertex)">
            <summary>
            Helper function. As p1 can be a vertex in any number of triangles, we want the one which includes
            segment p1p2; this will then be the triangle between p1 and the vertices of
            the returned symedge
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.FindFaceOfPoint(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Face)">
            <summary>
             Function that uses heuristic search to find the *first* triangle that includes
             point p. For numerical reasons, more than one face can include it, which is a problem
             that must be handled by the caller.
             The heuristic search uses half-plane tests and marking of the searched faces,
             and gives up when surrounded by marked faces. It then switches to linear search.
             NB: assumes that 'this' is currently a valid DCDT.
            </summary>
            <param name="p">The point we are looking for. Must be within the bounding box of the DCDT.</param>
            <param name="startFace">Either null or a *valid* face that is the starting point\
            for the heuristic search.</param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InsertVertex(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Insert a single vertex at location v. Three outcomes are possible: (1) v is epsilon-close
            to an existing vertex, in which case this vertex is simply returned. (2) v is
            epsilon-close to an existing edge, which means that we'll project it onto this edge,
            insert a vertex at the projected location, and retriangulate. (3) v is inserted
            within an existing face, in which case we simply retriangulate.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InsertVertexWithinEdge(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Insert vertex v within an existing edge using the MakeEV2() Euler operator. Afterwards,
            retriangulate and enforce the Delaunay property.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.InsertVertexWithinFace(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Face)">
            <summary>
            Insert vertex v within an existing face using 1x MakeEV() and 2x MakeEF() Euler operators.
            Afterwards, enforce the Delaunay property.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.DeletePolyline(System.Int32)">
            <summary>
            Delete the constraint with the given id, throws a NonExistentConstraintException if
            a constraint with this idea does not exist in the DCDT.
            
            Note that it is not guaranteed that the mesh is identical before insertion and after
            deletion, as DeletePolyline() cannot always remove 'administrative' vertices (which
            had to be inserted to accomodate existing constraints) and for numerical reasons.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.DeleteVertexAndRetriangulate(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Delete a single vertex and reinstate the DCDT afterwards (retriangulate, progapagte Delaunay property).
            </summary>
            <param name="s_with_vertex"></param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.EndpointsCanBeNewDiagonalOnLeft(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Very specialized function. Checks whether s1.Nxt -> s2.Nxt can be a diagonal of the face created
            by removing all the edges in rotational order from s1 to s2 (and including both). Note that s1 and s2 must be connected
            to the same vertex. Only symedges in the direction of s1 -> s2 are checked, so either the
            caller already knows that IsDiagonalOnLeft(s2, s1) is true, or they should
            make this call.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.TriangulateSimplePolygon(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.ActiveCognition.Symedge})">
            <summary>
            Numerically robust general-purpose algorithm for triangulating a simple polygon without holes.
            It is based on the concept of the Graham scan and performs in O(n^2) with very little overhead,
            meaning that it performs especially well if the polygon is small (as is almost always the case
            in the DCDT).
            The algorithm is described in Toussaint, Efficient triangulation of simple polygons, p.282f.
            This implementation adds code that ensures that the resulting triangulation is as numerically
            robust as can be. When it encounters a new ear, it checks first if the distance of the new diagonal
            to the vertex which is about to be cut off is >=this.Epsilon. The ear is passed over if this is not
            the case. This could result in an endless loop, so to avoid this, we do the following: whenever we
            circle the current face without cutting off an ear, we decrease Epsilon. If the polygon is non-degenerate,
            the algorithm will therefore terminate.
            After triangulation, the Delaunay property is propagated throughout the polygon and its vicinity in the mesh.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.IsNonDegenerateEar(VirtualBeings.Tech.ActiveCognition.Symedge,System.Double,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.Utils.Vec2})">
            <summary>
            Helper function for TriangulateSimplePolygon
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.RenewConcaveVertexSet(VirtualBeings.Tech.ActiveCognition.Symedge,System.Double,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.Utils.Vec2})">
            <summary>
            Helper function for TriangulateSimplePolygon
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.PropagateDelaunayProperty(VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.ActiveCognition.Symedge})">
            <summary>
            Enforce the Delaunay property for each edge in delaunaySet; and for each edge
            that has been flipped, enforce the property for all four edges of the enclosing
            quadrilateral. (No special treatment is necessary for edges close/on the border.)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.IsDelaunay_Precise(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Test if the current edge has the (local) Delaunay property.
            This is the case if the circumcircle of the three vertices of
            the present triangle does not (properly) contain the far vertex
            of the opposing triangle.
            
            If all four vertices are cocircular, the edge is Delaunay.
            
            This new version is more numerically robust (see code).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.CheckTopologicalIntegrityOfDCDT(System.Boolean)">
            <summary>
            Helper function. Uses various criteria to verify that the mesh is a valid
            constrained delaunay triangulation.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation.IsPolyLine(System.Int32,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.ActiveCognition.Edge})">
            <summary>
            Checks if an unordered (and possibly empty) set of edges can be arranged so
            that they form a polyline. Fast: builds up a dictionary (hashtable) which is
            then linearly traversed; O(n).
            PS: For our purposes, a set of edges forms a polyline iff (1) any its vertices can
            be reached from all others, and (2) none of its edges is degenerate (i.e., forms
            a loop of length one).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Mesh">
            <summary>
            Class that represents and manages a 2D-mesh based on the 'Symedge' concept (see Symedge.cs).
            *All* modifications of the mesh are achieved by the Euler operators originally introduced
            by Martti Mantyla in 1984. The basic idea of the operators is to allow topological modifications
            that leave the Euler property of a planar and connected (geometric) graph intact. In such
            a graph, the formula v  e + f = 2 always holds, where v = #nodes, e = #edges and f = #faces.
            It basically means that vertices and edges as well as faces and edges have to be inserted or
            deleted *together*; none of the three elements can be inserted/deleted by themselves.
            
            Both the rotational order of symedges connected to the same vertex and the sequential order
            of symedges connected to the same Face is counter-clockwise, CCW.
            
            An excellent account is found in Sven Havemann, Generative Mesh Modeling (PhD-Dissertation at
            U.Braunschweig, 2005), p.70
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.Vertices">
            <summary>
            List of all vertices in the mesh.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.Edges">
            <summary>
            List of all edges in the mesh.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.Faces">
            <summary>
            List of all faces in the mesh.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Mesh.FaceEventArgs">
            <summary>
            The following declarations and methods constitute the mechanism for broadcasting
            new / changed / deleted faces.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.UseEventSystem">
            <summary>
            Flag which de-/activates the face-change broadcasting system.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.ExternalDebugFlag">
            <summary>
            In the debug build, this flag controls if Debug code is executed or suspended.
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.ActiveCognition.Mesh.FaceInsertedOrChanged">
            <summary>
            Subscribe to this event to be notified about inserted faces (exception: OuterFace)
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.ActiveCognition.Mesh.FaceDeleted">
            <summary>
            Subscribe to this event to be notified about changed or deleted faces (exception: OuterFace)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.NotifyMeshAboutEdgeConstraintChanges(VirtualBeings.Tech.ActiveCognition.Edge,System.Boolean,System.Boolean)">
            <summary>
            Must be called by user of Mesh if changes to constraints of an edge are to
            be propagated to the neighboring faces.
            
            TODO: this is currently untested and not functional, this function is therefore
            not called (as it would have to be) by the DCDT.
            </summary>
            <param name="bAdd">true if constraint(s) have been added, false if removed</param>
            <param name="bMultiple">true if (possibly) more than one constraint was changed</param>
            <param name="e"></param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.ResetEvents">
            <summary>
            Clear all mesh events from subscribers.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.SomeValidFace">
            <summary>
            A face of Mesh that is not OuterFace.
            This value is used and changed by the user of Mesh, but maintained consistent
            by the Mesh class: whenever the face referred to is deleted, SomeValidFace is
            replaced by the face that now includes the killed face.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.SomeValidFaces">
            <summary>
            See description of SomeValidFace. This dictionary serves a similar function, but
            it can be empty (at the discretion of the user) whereas SomeValidFace
            *always* points at a valid face. Items in the list are kept consistent by Mesh.
            They must be indexed with an int identifier.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Mesh.OuterFace">
            <summary>
            The 'outermost' face of the mesh.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.NewVertex(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Create a new vertex from a pair of coordinates and register it.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.GenerateNewSearchIndex">
            <summary>
            See the explanation for property SearchIndex of class Face.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.MakeVFS_and_MakeEV(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            For initialization: Create a new, freestanding edge together with its face,
            pair of vertices and pair of symedges.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.MakeEV(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Create new vertex, new edge and pair of symedges, and connect them
            sequentially before and rotationally behind an existing symedge.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.KillEV(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Complementary operation to MakeEV(Symedge, Vec2); delete a vertex that is connected to a
            single edge, together with its edge.
            </summary>
            <param name="s">The symedge connected to the vertex that will be deleted.</param>
            <returns>s.Nxt</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.MakeEV2(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Create new vertex, new edge and pair of symedges, and connect them
            between two (distinct) symedges that are connected to the same vertex.
            Afterwards, s1 will be connected to the new vertex while s2 remains
            with its old one.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.KillEV2(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Complementary operation to MakeEV2(Symedge, Symedge, Vec2); used to kill an edge
            and vertex for the case that the vertex is connected to at least one additional edge.
            </summary>
            <param name="s">The Symedge whose edge and vertex are to be killed.</param>
            <returns>s.Nxt</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.MakeEF(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Create new edge and pair of symedges, and insert them between
            two existing symedges, thereby making a new face.
            <returns>The symedge that points at the old face.</returns>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.KillEF(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            Delete an existing edge (s.Edge) and face (s.Face), and rewire all symedges within
            the new face to refer to s.Sym.Face.
            <param name="s">The symedge whose edge will be deleted.</param>
            <returns>s.Ret</returns>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.EdgeFlip(VirtualBeings.Tech.ActiveCognition.Symedge)">
            <summary>
            If v1v3 is the single diagonal of a convex (!) quadrilateral v1v2v3v4, this function
            can be used to 'flip' the edge to connect v2v4.
            This is the basic operation for maintaining a Delaunay triangulation.
            </summary>
            <param name="s">Any Symedge of the edge that will be flipped.</param>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Mesh.CheckMeshIntegrity(System.Boolean)">
            <summary>
            Helper function. Uses various criteria to verify that the mesh has basic
            integrity at the data-structure level. It does *not* verify topology, since the
            Mesh class does not make assumptions about topology.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.MeshElement">
            <summary>
            Auxilliary classes for the Symedge class as explained in the following article:
            "Navigation Queries from Triangular Meshes", Marcelo Kallmann, 2010.
            
            Note that only class Vertex contains geometric information while only Symedge
            is used to store topological information. Face and Edge are purely administrative
            classes.
            
            Edge and Vertex can store information about the 'constraints' they belong to.
            
            MeshElement simply stores info that is common to Vertex, Edge and Face.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.MeshElement.ThisNode">
            <summary>
            'Nodes' are used by LinkedList(T) to store an element and connect it to previous/next element.
            The Mesh datastructue saves all MeshElement in linked lists, one for each type. The following
            property ThisNode links the element back to the node that packages it.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.MeshElement.Symedge">
            <summary>
            All MeshElements refer to exactly one Symedge.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.MeshElement.Reset">
            <summary>
            Reset this object (to recycle it after object-pooling).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Edge">
            <summary>
            Representation of an Edge in the Mesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Edge.Reset">
            <summary>
            Reset this object (to recycle it after object-pooling).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Edge.DebuggerSummary">
            <summary>
            Textual summary of the current instance, useful for debugging
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Face">
            <summary>
            Representation of a Face in the Mesh. If it is a triangle, it can also store links to its
            0-3 neighbors, thus serving as a 'graphnode' class from which a triangulation graph is constructed.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.SearchIndex">
            <summary>
            When faces are searched (for point insertion etc.), the current search index
            is used in order to avoid searching the same face twice. If a face's search
            index == CurrentSearchIndex, it has been visited, otherwise not.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Face.Reset">
            <summary>
            Reset this object (to recycle it after object-pooling).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Face.HasAccessibleNeighbor(VirtualBeings.Tech.ActiveCognition.Face)">
            <summary>
            Check if otherFace is an accessible neighbor of this face.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.Quadrilateral">
            <summary>
            Property that returns true if the current face is a Quadrilateral.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.Triangular">
            <summary>
            Property that returns true if the current face is a Triangle.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.TriangularCentroid">
            <summary>
            Property that returns the centroid; can only be used if 'this.Triangular' is true. The centroid is
            cheap to calculate but we use it often for pathfinding, so we chache it.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.TriangularIncenter">
            <summary>
            Property that returns the centroid; can only be used if 'this.Triangular' is true.
            The Incenter is expensive to calculate and so we chache it as well.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.HasChanged">
            <summary>
            Write-only property that serves to inform the face that its geometry has changed.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Face.DebuggerSummary">
            <summary>
            Textual summary of the current instance, useful for debugging
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Vertex">
            <summary>
            Representation of a Vertex in the Mesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Vertex.Reset">
            <summary>
            Reset this object (to recycle it after object-pooling).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Vertex.DebuggerSummary">
            <summary>
            Textual summary of the current instance, useful for debugging
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Symedge">
            <summary>
            The Symedge class as explained in the following excellent article:
            "Navigation Queries from Triangular Meshes", Marcelo Kallmann, 2010.
            
            It serves as a basic building block for any kind of 2D mesh.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Symedge.Nxt">
            <summary>
            The following C#-Properties realize Kallmann's ingenious traversal operators.
            Correctly chained they can be used to access any location in the mesh from any other.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.ActiveCognition.Symedge.DebuggerSummary">
            <summary>
            Textual summary of the current instance, useful for debugging
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder">
            <summary>
            Class that encapsulates all algorithms for pathfinding in a DCDT.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindPath_AStar(VirtualBeings.Tech.ActiveCognition.Face,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},System.Int32)">
            <summary>
            Find a path from Face 'start' to Face 'end', or return null if none exists.
            This is an implementation of the A* algorithm, based on the explanations and
            pseudocode at http://en.wikipedia.org/wiki/A*_search_algorithm
            
            NB: A* cannot always find Euclidean shortest paths in a general navmesh, and will frequently return suboptimal paths.
            Furthermore, its not even faster than RS-BF, as I've determined through various large-scale experiments.
            
            NB: creates garbage, not for production use.
            
            <param name="AStarMode">0 = centroids, 1 = incenters, 2 = centroids for g-score, point on triangle-border
            closest to 'vEnd' for h-score</param>
            <param name="fStart"></param>
            <param name="vStart"></param>
            <param name="vEnd"></param>
            <param name="lResultBuffer"></param>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.DFSNode">
            <summary>
            Helper class to store data for depth-first search.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.DFSNode.Contains(VirtualBeings.Tech.ActiveCognition.Face)">
            <summary>
            Simple linear search to see if face already exists on current path.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindPath_Exhaustive(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner})">
            <summary>
            Carry out an exhaustive search for a shortest path between two Vec2 points in a DCDT.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetLengthInChannel(VirtualBeings.Tech.ActiveCognition.Pathfinder.DFSNode,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            A wrapper to give FindPath_Exhaustive access to the funnel algorithm
            <param name="lastDfsNode">Must be non-null</param>
            <param name="vStart"></param>
            <param name="vEnd"></param>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetCornersOfChannel(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2}[],System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner})">
            <summary>
            Implements Chazelle's funnel algorithm. See Li and Klette, Euclidean shortest paths, Springer, 2011, ch. 6.
            However, the following function is quite different and seems to conform to Chazelle's algorithm only in spirit.
            <param name="borders">Array of length two of two Lists of identical length >= 3, containing the left and right
            vertices bordering the channel (including the start and end-points, which must be identical in both Lists.
            </param>
            <param name="lResultBuffer">The corners in reverse order</param>
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.Pathfinder._DCDT">
            <summary>
            Reference to a DCDT used for pathfinding
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetNextAvailablePositionID">
            <summary>
            Get a new unique identifier for the DCDT to keep track of. Use one ID for each agent
            and never change it while DCDT is running.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.Pathfinder._BoundaryExpansionFactor">
            <summary>
            Explained in the code of ExtractBoundariesFromChannel()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.#ctor(VirtualBeings.Tech.ActiveCognition.DynamicallyConstrainedDelaunayTriangulation)">
            <summary>
            Standard constructor - a DCDT is always necessary
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.DCDTChanged(System.Object,System.EventArgs)">
            <summary>
            Event listener that processes macro-changes to the DCDT
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetRadialSortObject">
            <summary>
            TODO
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.InsertOrUpdatePosition(System.Int32,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Class Pathfinding can store an arbitrary number of 'position' references, in order to
            make retrieval of their containing face more efficient. Each position is named with
            a unique id (supplied by the owner). Actual storage takes place in the Mesh class.
            
            This function updates an existing position -=OR=- inserts/updates a new position reference.
            In the former case, it is very fast if the position has not changed (much). Otherwise, its speed
            depends linearly on the number of faces over which the position
            has been moved in the navmesh.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.RemovePosition(System.Int32)">
            <summary>
            Removes a position-name that has previously been registered with InsertOrUpdatePosition().
            Use is recommended whenever the reason for the existence of a position (e.g., an agent) is being removed.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.SymedgeAndDistance">
            <summary>
            Struct for the priority queue in GetLengthOfStraightCorridor();
            it is a pair consisting of a symedge that intersects the corridor, and the distance of the closest
            obstacle on the intersection symedge/corridor (or MaxValue if there's no such obstacle)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.SymedgeDistancePoint">
            <summary>
            Struct for the priority queue in GetClosestObstacle()/GetClosestObstacleInSector.
            Like SymedgeAndDistance, but we also store the closest obstacle as a point so that it
            can be returned to the user.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetLengthOfStraightCorridor(System.Int32,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Calculate the largest rectangular corridor for an agent of width 'width' at position 'currentPosition'
            in the direction 'desiredDirection' (up to desiredDirection.Magnitude).
            
            This function is geometrically correct, meaning that it solves the "departure problem". (However, in the unlikely case
            that you really need it to solve the departure problem even for the backward half of the agent, you should make
            sure that 'currentPosition' is at the rear of the agent, not at its center.)
            
            NB: This function does not try to be numerically robust, so if the actual corridor has width 'width',
            the function may decide that it is blocked.
            
            NB: If the agent is currently intersecting an obstacle at the baseline of the
            corridor, we return 0.
            
            Algorithm:
            
            - for the geometric operations below, we use the following names for the six relevant points,
              where C = currentPosition and D-C = desiredDirection:
            
            |--width--|
            Dl - D - Dr
                 ^
                 |
                 |
            Cl - C - Cr
            
            - create a priority queue of Pairs which store a symedge *in* the corridor and the distance of the closest obstacle on it;
              the priority is the closest point (obstacle or not) relative to the corridor-base ClCr of the intersection symedge/corridor
            - create a set of edges to keep track of which edges have already been processed
            - calculate start-face
            - put (looking from startface) all Symedge.Sym's into PQ that intersect corridor base ClCr
            - also put (if it exists) that symedge of the startface in the PQ which crosses
              (C->D) and isn't yet in the edge-set
            - loop over PQ: for each dequeued pair, see if it has an obstacle and, if so, if it's the closest so far
            - check if the two neighboring symedges of the dequeued symedge are in the corridor and calculate their closest
              obstacle (if any); enqueue them if they cross the corridor (whether or not they have an obstacle)
            - during the previous step, use the set to ensure that edges are never processed twice
            - termination criterion: PQ is empty, or an item is dequeued whose priority is greater-or-equal than the
              distance of the closest obstacle so far (this is important - by the design of the algorithm, we now know that
              no unprocessed edge can exit that provides a closer obstacle than the currently closest one)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetMaximumTurnRadiusAtUpcomingCorner(System.Int32,System.Double,System.Double,System.Double,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Corner,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Calculate how tightly the upcoming corner has to be circumnavigated. The function returns the maximum turn radius
            (up to desiredMaxTurnRadius, which should be set as small as possible!) enforced by the worst obstacle in the vicinity
            around and behind the corner.
            
            In its current state, the function assumes non-anticipatory steering: the agent moves to the upcoming corner (offset
            at half his clearance) and only starts turning when he is perpendicular to it.
            
            turnRadiusExtensionDueToSlowTurnOnset should be set to > 1.0 to account for the fact that the effective turn radius
            will be worse because the agent begins/ends turning in a continuous manner.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestObstacle(System.Int32,VirtualBeings.Tech.Utils.Vec2,System.Double,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Simple wrapper to find the (navigation-local) position of the closest obstacle from currentPosition.
            This is returned in the out parameter closestObstacle (which may be Invalid if no obstacle was found within maxDistance)
            Return value: distance of the closest obstacle, or maxDistance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestObstacleBehindCorner(System.Int32,System.Double,System.Double,VirtualBeings.Tech.Utils.Vec2@,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Corner,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Simple wrapper that applies GetClosestObstacleInSector() to find the closest obstacle.
            offsetFromCorner is used to ensure that the corner itself won't be returned as its closest obstacle, I
            recommend setting it to something like .01 of the clearance of the character.
            Return value: distance of the closest obstacle behind corner, or maxDistance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestObstacleInSector(System.Int32,VirtualBeings.Tech.Utils.Vec2,System.Double,VirtualBeings.Tech.Utils.Vec2@,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Like GetClosestObstacle(), but search of obstacles remaines confined to the sector of a disk bordered, on the left, by
            sectorLeftSide, and on the right by sectorRightSide. Both these vectors must be in world space.
            Return value: distance of the closest obstacle in sector, or maxDistance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestObstacle_Internal(System.Int32,VirtualBeings.Tech.Utils.Vec2,System.Double,VirtualBeings.Tech.Utils.Vec2@,System.Boolean,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            GetClosestObstacle() and GetClosestObstacleInSector() use the same overall algorithm and are therefore
            implemented via this single function; only the subroutine for finding the closest obstacle on a segment is different.
            
            Note that the circle sector defined by sectorLeftSide, sectorRightSide must less than Pi.
            
            Return value: distance of the closest obstacle, or maxDistance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestPointsOnSegment(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2,System.Double@,System.Double@,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Helper for GetClosestObstacle_Internal(). Finds the closest obstacle on s w.r.t. currentPosition. One of {s.Vtx.V, s.Nxt.Vtx.V} if s.Edge is unconstrained.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestPointsOnSegmentInSector(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double@,System.Double@,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Like GetClosestPointsOnSegment(), but this version is more complex because it focuses only
            on the part of s which is inside a circle sector (which must be less than Pi).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindOptimalSteeringTargetAlongPath(System.Int32,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Int32,System.Double,System.Double,System.Boolean@)">
            <summary>
            Replaces FindFreeCorridorAlongPath, which was problematic and too complex
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetClosestPointsOnSegmentInCorridor(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double@,System.Double@,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Calculate the distances of the closest point and the closest constrained point that lie on the intersection
            of a segment with a corridor. If one or both points don't exist, distances are set to MaxValue.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetOptimalTargetInCorridorBasedOnSymedge(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,System.Double@,VirtualBeings.Tech.Utils.Vec2@,System.Int32@)">
            <summary>
            Very specialized function used by FindFreeCorridorAlongPath().
            Calculates the distance of the closest point that lies on the intersection
            of a segment with a corridor. Also, calculates the closest constrained
            point (if it exists) vis-a-vis the line mA-mB.
            If one or both points don't exist, distances are set to MaxValue.
            
            'sign' refers to optimalTarget and can be: 1=left, -1=right, 0=both
            
            Assumes all Vec2 parameters are distinct, except possibly C==mA and D==mB!
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.Raycast(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Int32)">
            <summary>
            Does what it says it does - gets the length of the longest ray from start to end that doesnt
            *properly* cross a constrained segment. 'Properly' means here that the algorithm ignores segments
            it crosses on or epsilon-near a vertex.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.DoesEdgeBlockRaycast(VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Method used by Raycast(), assumes that s intersects with start-end and that s.Vtx.V is 'left'
            and s.Nxt.Vtx.V is 'right'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetChannelForSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Int32,System.Boolean,VirtualBeings.Tech.ActiveCognition.Face,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Symedge})">
            <summary>
            Get the 'channel' of points start and end. A channel is a sequence of triangles crossed by
            the line segment start-end (excluding the triangle that includes start, but including the one
            that includes end if it is distinct from start's).
            </summary>
            <param name="start">Starting point; must be within the bounds of the navmesh</param>
            <param name="end">End point; can be anywhere</param>
            <param name="positionID">Optional name of a registered position (see above) to
            begin the search for the face containing 'start' in the mesh.</param>
            <param name="bTraverseConstrained">If true, don't halt upon encountering a constrained edge. If false,
            the algorithm still adds the first constrained edge it encounters to the channel</param>
            <param name="startFace">Can be set to the face that includes start (if it's already known)</param>
            <param name="channel">If non-null, the channel will be appended to this collection</param>
            <returns>List of Symedges that refer to the triangular faces of the channel. If empty, then
            start and end are in the same triangle.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetChannelClearance(System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Symedge},System.Double)">
            <summary>
            O(n^2) - algorithm for calculating the clearance of a channel in a DCDT.
            This is, I believe, optimal *if* the algorithm cannot/may not use corners.
            (When using corners, this should be possible in O(n); RS-BF calculates its
            clearance on-line in (on average) O(1) at each node.)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.ExtractBoundariesFromChannel(System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Symedge},System.Double,VirtualBeings.Tech.Utils.PolyLine,VirtualBeings.Tech.Utils.PolyLine)">
            <summary>
            Extract the left and right boundaries of a channel. If the channel is empty, both boundaries
            will be empty as well.
            This improved version takes into account that the channel does not necessarily consist
            of constrained symedges. It can thus calculate a broader channel.
            NB: the symedges in the channel have to be sorted 'forward'/'ascending', and each two subsequent
            symedges must share one Vertex.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.ExpandPolyLineFromSymedge(System.Double,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.ActiveCognition.Symedge,VirtualBeings.Tech.Utils.PolyLine,System.Boolean)">
            <summary>
            TODO explain better.
            Expands the poly line from symedge.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindPath_RSBF(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},System.Double@,System.Int32,System.Double,System.Double,VirtualBeings.Tech.ActiveCognition.PathInspector)">
            <summary>
            Use RS-BF to find a (near) optimal path from start to end, return true if successful.
            </summary>
            <param name="start">Starting point; must be within the bounds of the navmesh</param>
            <param name="end">End point; must be within the bounds of the navmesh</param>
            <param name="lResultBuffer">In case of succes, this is used to fill list of found corners (which includes the goal)</param>
            <param name="distanceToFirstBlock">The distance (or MaxValue) beyond which blockingClearance
            (which should be larger than clearance) isn't supported anymore</param>
            <param name="positionID">Optional name of a registered position (see above) to
            begin the search for the face containing 'start' in the mesh.</param>
            <param name="clearance">Minimum clearance (or object diameter) to guarantee during the path search.
            NB: this parameter is ignored if bUseRSBF = false!</param>
            <param name="blockingClearance">If the caller wants to be notified about the distance at which the found path starts to get
            'thin' (less than this parameter), set this to a value greater than 'clearance', otherwise leave at zero when not needed.</param>
            <param name="pathInspector"></param>
            <returns>Null if no path exists. If a path exists, we return a non-empty list of corners, where the last 'corner' is
            the 'end' (and its SIDE obviously doesn't matter).</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindPath(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},System.Int32,System.Double,System.Boolean,System.Int32,VirtualBeings.Tech.ActiveCognition.PathInspector)">
            <summary>
            Find a channel from 'start' to 'end'. Both 'start' and 'end' must be within the bounding box of the DCDT.
            If such a channel does not exist (because it would have to cross a constraint), return false.
            Otherwise, return true. In that case, 'path' will hold a list of Symedges, possibly empty, that mark the
            edges that the path traverses. TODO graphic that explains that these are the ".Sym" symedges, left-to-right.
            </summary>
            <param name="start">Starting point; must be within the bounds of the navmesh</param>
            <param name="end">End point; must be within the bounds of the navmesh</param>
            <param name="lResultBuffer"></param>
            <param name="positionID">Optional name of a registered position (see above) to
            begin the search for the face containing 'start' in the mesh.</param>
            <param name="clearance">Minimum clearance (or object diameter) to guarantee during the path search.
            NB: this parameter is ignored if bUseRSBF = false!</param>
            <param name="bUseRSBF">If true, uses RS-BF algorithm; if false, uses A*</param>
            <param name="AStarMode">0 = centroids, 1 = incenters, 2 = centroids for g-score, point on triangle-border
            closest to 'vEnd' for h-score</param>
            <param name="pathInspector"></param>
            <returns>Null if no path exists. If a path exists, we return a list of corners, where the last 'corner' is
            the 'end' (and its SIDE obviously doesn't matter).</returns>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetPathLength(VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate the minimum length of a path from start to end that traverses 0..n corners
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.GetPathLengthGivenAgentRadius(VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},System.Double)">
            <summary>
            Estimate the minimum length of a path from start to end that traverses 0..n-1 corners,
            for an agent with radius 'radius' (the last 'corner' is the end).
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.ActiveCognition.Pathfinder.LEFT">
            <summary>
            Throughout the RSBF-algorithm, LEFT=0 and RIGHT=1 hold and can
            be used for array-indexing
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.PathCorner">
            <summary>
            Helper class for the FindChannel-algorithm
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode">
            <summary>
            Helper class for the FindChannel-algorithm.
            Note that 'OwnSymedge' is always oriented left-to-right, and this directionality matters.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNeighbor">
            <summary>
            Helper class; only needed to iterate over the neighbors of a node
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.FindPath_RSBF_Internal(VirtualBeings.Tech.ActiveCognition.Face,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Collections.Generic.List{VirtualBeings.Tech.ActiveCognition.Corner},System.Double,System.Double,VirtualBeings.Tech.ActiveCognition.Symedge@,VirtualBeings.Tech.ActiveCognition.PathInspector)">
            <summary>
            Find a path from Face 'start' to Face 'end' with minimum clearance 'clearance'.
            This is an implementation of RS-BF. See my unpublished manuscripts.
            
            This augmented version from 2015 also returns, via 'blockingSymedge', the first symedge (or null) that creates
            a block in the path for an agent with clearance 'blockingClearance' (where blockingClearance obviously should be higher than clearance).
            This is used in pathfinding to allow switching between different locomotion types. E.g., path-search can focus on the most
            clearance-efficient locomotion type (e.g., walk), and the blocking symedge warns the user when this locomotion type has to be used.
            
            This augmented version from 2017 uses a PathInspector to find incomplete-but-desirable paths of almost any type.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.CenterOfAgentMustCrossLastSymedgeToReachVEnd(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Helper function for RS-BF
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.CenterOfAgentWouldHaltBeforeProblematicSymedge(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,VirtualBeings.Tech.Utils.Vec2,System.Double,System.Collections.Generic.Dictionary{VirtualBeings.Tech.ActiveCognition.Face,VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode})">
            <summary>
            Helper function for RS-BF
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.HasVertexInCorner(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,VirtualBeings.Tech.ActiveCognition.Pathfinder.PathCorner)">
            <summary>
            Helper function for RS-BF
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.ActiveCognition.Pathfinder.CalculateClearanceAtNode(VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode,System.Double,System.Collections.Generic.Dictionary{VirtualBeings.Tech.ActiveCognition.Face,VirtualBeings.Tech.ActiveCognition.Pathfinder.PathNode})">
            <summary>
            Helper function for RS-BF
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.ActiveCognition.Corner">
            <summary>
            A list of Corners is returned by each of the pathfinding algorithms. SIDE denotes
            whether the corner has to be passed on the left- or right-hand side in the direction
            of the goal. E.g., 'R' means that the corner is to the left of the path and has to be
            circled on the right.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.AdjustMoveToSpeed.Easing">
            <summary>
            Speed target easing over distance
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.DirectionalTargetFunc">
            <summary>
            This is the 'directional target', it serves as a reference point to look around from - if null, forward is used
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.AvoidanceTargetInteractable">
            <summary>
            Optionally, an Interactable we want to avoid (often the player)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.BodyWeight">
            <summary>
            (Only relevant for humanoids) [0,1] Determines how much the body is involved in the LookAt.
            One should be careful when using high values for the body, as it can end-up with un-natural poses when
            the look target is in "extreme" places (e.g. behind).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.ClampLookWeight">
            <summary>
            (Only relevant for humanoids) [0,1] 0 means the being in unrestrained in motion.
            1 means the character is clamped (LookAt becomes impossible). 0.5 means the being is able to move on half its
            possible motion range.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.EyesClosed01">
            <summary>
            How much eyes should be closed, from 0 (same as base expression) to 1 (eyes closed)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAround.IsDistracted">
            <summary>
            Are we currently looking at a distracting event?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAround.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,VirtualBeings.Tech.BehaviorComposition.IEmoter,System.Func{UnityEngine.Vector3},System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single,System.Single,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Single,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            TODO
            </summary>
            <param name="parent"></param>
            <param name="emoter"></param>
            <param name="directionalTargetFunc"></param>
            <param name="minAngleToZero">ensure that the combined result of yaw and pitch gives an angle of at least MinAngle</param>
            <param name="minAngleToPrevious">avoid looking at previous 2 targets</param>
            <param name="minPitch"></param>
            <param name="maxPitch"></param>
            <param name="preferredPitchSign">0, 1 or -1. If 0, there will be no particular preference over the initial
            target pitch. After the initial one has been picked, pitch sign will change every two look changes.
            If non 0, initial pitch sign will be decided by this value. And the look loop will be 3 looks on the
            preferredPitchSign, then 1 look on the other, and loop.</param>
            <param name="maxYaw"></param>
            <param name="averageDuration"></param>
            <param name="durationVariationFactor"></param>
            <param name="avoidanceTargetInteractable"></param>
            <param name="minAngleToGlobalPositionToAvoid"></param>
            <param name="expression"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAround.Push(UnityEngine.Vector2@,UnityEngine.Vector2,System.Single,VirtualBeings.Tech.BehaviorComposition.LookAround.Bounds,VirtualBeings.Tech.BehaviorComposition.LookAround.Bounds)">
            <summary>
            Ensure that target is at least distance 'minAngle' away from pushFrom by pushing target linearly away
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.Initialize">
            <summary>
            Used to initialize fields, e.g. PS members, etc (cf RootDomainActuator for example)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.Reset(VirtualBeings.Tech.BehaviorComposition.IRS)">
            <summary>
            Called on a request to Actuator.Reset(). Should be used to reset internal fields (e.g. PS).
            cf RootDomainActuator for example
            </summary>
            <param name="irs"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.PreUpdate">
            <summary>
            Called it the beginning of the Update from the Actuator Container. Can be used to prepare data (eg used by the
            NeckHead domain to evaluate the look targets)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.Update">
            <summary>
            Called during update. For example used by the body domain to update the FFBIK or NeckHead anim jobs.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.PostUpdate">
            <summary>
            Called at the very end of the Update. Can be used to do stuff after all other domains have done their update
            (eg used by the Grounding domain actuators to do the grounding and prepare for the body's next update)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.VoiceDomainActuator.LateUpdate(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Called during Unity's LateUpdate. eg Root domain implements it
            </summary>
            <param name="positionAtLastFrame"></param>
            <param name="rotationAtLastFrame"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.LookBase">
             <summary>
             Abstract general-purpose encapsulation for LookAt that is distractible and provides basic behavioral variations
            
             TODO: in the future, also handle expressions / emotions
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase._TargetFunc">
            <summary>
            Change look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase._TargetIInteractable">
            <summary>
            Change look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.MaxDistractionDuration">
            <summary>
            Shorten default distraction duration? (E.g., when being is nervy or busy or uninterested).
            0f means 'not distractible'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.RandomizeHeadLookDirection(System.Boolean)">
            <summary>
            Switch small random directional variations on/off
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.RandomizeEyesLookDirection(System.Boolean)">
            <summary>
            Switch small random directional variations on/off
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.TerminationRequested">
            <summary>
            Implements ITerminatable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.HeadWeight01">
            <summary>
            How much the head follows the look target
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.BodyWeight01">
            <summary>
            (Only relevant for humanoids) [0,1] Determines how much the body is involved in the LookAt.
            One should be careful when using high values for the body, as it can end-up with un-natural poses when
            the look target is in "extreme" places (e.g. behind).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.ClampLookWeight01">
            <summary>
            (Only relevant for humanoids) [0,1] 0 means the being in unrestrained in motion.
            1 means the character is clamped (LookAt becomes impossible). 0.5 means the being is able to move on half its
            possible motion range.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.MinHeadWeight01DuringDistraction">
            <summary>
            Min head weight that gets used when we're distracted. Must be 0..1.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.EyeWeight01">
            <summary>
            How much the eyes follow the look target (see LookAt for details)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.EyesClosed01">
            <summary>
            How much eyes should be closed, from 0 (same as base expression) to 1 (eyes closed)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.ConfigureLookStabilization(System.Boolean,System.Single,System.Single,System.Single)">
            <summary>
            Allow the look direction to be 'frozen' until either 1) some time has passed or 2) the angle to look target has changed.
            This achieves look-at patterns that are typical of birds.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.DoEmote">
            <summary>
            Should there be randomized emoting (e.g., ear movements for cats)?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoMouthOpen(System.Single,System.Single)">
            <summary>
            Open/close the mouth (strictly additive)
            </summary>
            <param name="mouthOpen01"></param>
            <param name="urgencyFactor01"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoHeadRoll(System.Single,System.Single)">
            <summary>
            Add an intentional roll offset to the head (released upon distraction).
            NB: this is an acceptable use pattern as it's not assumed that the underlying LookAt behavior has domain control.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoHeadPitch(System.Single,System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoHeadYaw(System.Single,System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoEyePitch(System.Single,System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoEyeYaw(System.Single,System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.ReleaseLookAtOffsets(System.Boolean,System.Boolean)">
            <summary>
            Release intentional offsets from head and/or eyes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoAdditiveExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request a neck-head-face expression (yawn, meow etc)
            NB: intensity is remapped (because of data-driven min/max intensity) as is speed01 (which gets remapped to a multiplier).
            However, volume01 and leftRight are not remapped.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.DoFST(VirtualBeings.Tech.BehaviorComposition.IFST,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request a facial self-transition (FST)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.TerminateAdditiveExpression(System.Single)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsInAnimatedExpression">
            <summary>
            Are we either in an additive expression (yawn, meow etc) or a transition expression (OT or ST)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsInAdditiveExpression">
            <summary>
            Is a neck-head-face additive expression (yawn, meow etc) ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsInFOTorFST">
            <summary>
            Is a neck-head-face transition expression (OT or ST) scheduled or ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsInFOT">
            <summary>
            Is a neck-head-face FOT scheduled or ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsInFST">
            <summary>
            Is a neck-head-face FST scheduled or ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookBase.IsDistracted">
            <summary>
            Are we currently looking at a distracting event?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean,System.Boolean,System.Single,VirtualBeings.Tech.BehaviorComposition.IEmoter,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            Use this constructor to look (initially) at an IInteractable. Can be null, and can later be changed to a Func(Vector3).
            If null, the being will look straight ahead into the distance.
            NB: eye weight always defaults to 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,System.Func{UnityEngine.Vector3},System.Boolean,System.Boolean,System.Single,VirtualBeings.Tech.BehaviorComposition.IEmoter,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            Use this constructor to look (initially) at a position provided by a Func(Vector3). Can be null, and can later be changed to an IInteractable.
            If null, the being will look straight ahead into the distance.
            <param name="headWeight">[0,1] Determines how much the head is involved in the LookAt</param>
            <param name="eyeWeight">[0,1] Determines how much the eyes are involved in the LookAt</param>
            <param name="bodyWeight">(Only relevant for humanoids) [0,1] Determines how much the body is involved in the LookAt.
            One should be careful when using high values for the body, as it can end-up with un-natural poses when
            the look target is in "extreme" places (e.g. behind).</param>
            <param name="clampLookWeight">(Only relevant for humanoids) [0,1] 0 means the being in unrestrained in motion.
            1 means the character is clamped (LookAt becomes impossible). 0.5 means the being is able to move on half its
            possible motion range.</param>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.StartInternal(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Single)">
            <summary>
            Look (initially) at an IInteractable. Can be null, and can later be changed to a Func(Vector3).
            If null, the being will look straight ahead into the distance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.StartInternal(System.Func{UnityEngine.Vector3},System.Single)">
            <summary>
            Look (initially) at a position provided by a Func(Vector3). Can be null, and can later be changed to an IInteractable.
            If null, the being will look straight ahead into the distance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.GetLookTarget">
            <summary>
            Arbiter method that's handed to LookAt.
            NB: It can also change LookAt. These changes will only be processed by LookAt in the following frame.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.OnSalientEvent(VirtualBeings.Tech.UnityIntegration.AgentEvent_Salient)">
            <summary>
            NB: reminder on how salient events are dispatched:
            - FOVTrackerGear calls InteractableMemory.MarkUpdated() for each tracked interactable in FOV at each update (multiple times per second)
            - criterion for event raising is "tv.Interestingness01 > _settings.ThresholdForInterestingEvents"
            - if met, event is then raised MarkUpdated() via call into TrackedEventDB.PostMovementEvent()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.MainProcess">
            <summary>
            This process mainly creates small expressive movements (smacks etc).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookBase.ResetEyesTimer">
            <summary>
            TODO: This is an hardcoded and simple way to spend more time in the "no offset" eyes look position
            that in the "look outwards" position.
            </summary>
            <param name="eyesLookedOutside"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.LookDouble">
            <summary>
            Like LookSimple, but look intermittently at two targets
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDouble.TargetFuncPrimary">
            <summary>
            Change primary look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDouble.TargetInteractablePrimary">
            <summary>
            Change primary look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDouble.TargetFuncSecondary">
            <summary>
            Change secondary look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDouble.TargetInteractableSecondary">
            <summary>
            Change secondary look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDuringMoveTo.IsDistractible">
            <summary>
            Look at distraction (if available)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookDuringMoveTo.DurationVariationFactor">
            <summary>
            How much look time can vary, used to define a range as in [X / DurationVariationFactor, X * DurationVariationFactor].
            Clamped between 1f and 5f.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookIntermittent.EyesClosed01_OnInteractable">
            <summary>
            How much eyes should be closed while looking at interactable, from 0 (same as base expression) to 1 (eyes closed)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookIntermittent.IsDistracted">
            <summary>
            Are we currently looking at a distracting event?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookIntermittent.MaxDistractionDuration">
            <summary>
            Look at distraction (if available)?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookIntermittent.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,VirtualBeings.Tech.BehaviorComposition.IEmoter,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
             Toggle between looking at a target and just looking around
            </summary>
            <param name="parent"></param>
            <param name="emoter"></param>
            <param name="interactable"></param>
            <param name="headWeight">How much this look control the head [0 ; 1]</param>
            <param name="averageLookAtInteractableDuration">Duration to look at interactable</param>
            <param name="averageLookAroundDuration">Duration to look around</param>
            <param name="averageLookAroundVariationDuration">How much variation for duration do we want when looking at interactable. 1 = no variation. 2 = 2 times slower to 2 times faster.</param>
            <param name="minAngleToPreviousForLookAround"></param>
            <param name="minPitchForLookAround">TODO</param>
            <param name="maxPitchForLookAround">TODO</param>
            <param name="maxYawForLookAround">TODO</param>
            <param name="minAvoidanceAngleForLookAround">TODO</param>
            <param name="durationVariationFactor">Here 1 means no variation; a good value is 1.25</param>
            <param name="expression"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.LookSimple">
            <summary>
            General-purpose encapsulation for LookAt that is distractible and that optionally varies pitch/yaw
            in a gentle, randomized manner; also adds some random mouth movements (smacks...)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookSimple.TargetFunc">
            <summary>
            Change look target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookSimple.TargetInteractable">
            <summary>
            Change look target (can be null)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookSimple.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean,System.Boolean,System.Single,VirtualBeings.Tech.BehaviorComposition.IEmoter,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            Use this constructor to look (initially) at an IInteractable. Can be null, and can later be changed to a Func(Vector3).
            If null, the being will look straight ahead into the distance.
            <param name="headWeight">[0,1] Determines how much the head is involved in the LookAt</param>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookSimple.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,System.Func{UnityEngine.Vector3},System.Boolean,System.Boolean,System.Single,VirtualBeings.Tech.BehaviorComposition.IEmoter,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            Use this constructor to look (initially) at a position provided by a Func(Vector3). Can be null, and can later be changed to an IInteractable.
            If null, the being will look straight ahead into the distance.
            <param name="headWeight">[0,1] Determines how much the head is involved in the LookAt</param>
            <param name="eyeWeight">[0,1] Determines how much the eyes are involved in the LookAt</param>
            <param name="bodyWeight">(Only relevant for humanoids) [0,1] Determines how much the body is involved in the LookAt.
            One should be careful when using high values for the body, as it can end-up with un-natural poses when
            the look target is in "extreme" places (e.g. behind).</param>
            <param name="clampLookWeight">(Only relevant for humanoids) [0,1] 0 means the being in unrestrained in motion.
            1 means the character is clamped (LookAt becomes impossible). 0.5 means the being is able to move on half its
            possible motion range.</param>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookSimple.Start(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Single)">
            <summary>
            Look (initially) at an IInteractable. Can be null, and can later be changed to a Func(Vector3).
            If null, the being will look straight ahead into the distance.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookSimple.Start(System.Func{UnityEngine.Vector3},System.Single)">
            <summary>
            Look (initially) at a position provided by a Func(Vector3). Can be null, and can later be changed to an IInteractable.
            If null, the being will look straight ahead into the distance.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookWatchfullyAndVocalize.EyesClosed01">
            <summary>
            How much eyes should be closed while looking, from 0 (same as base expression) to 1 (eyes closed)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookWatchfullyAndVocalize.MaxDistractionDuration">
            <summary>
            Look at distraction (if available)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookWatchfullyAndVocalize.TimeToFirstVocalization">
            <summary>
            Configuration of subactivity Vocalize
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookWatchfullyAndVocalize.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,VirtualBeings.Tech.BehaviorComposition.IEmoter,VirtualBeings.Tech.UnityIntegration.IInteractable,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper})">
            <summary>
            Toggle between looking at a target and just looking around
            </summary>
            <param name="parent"></param>
            <param name="emoter"></param>
            <param name="interactable"></param>
            <param name="headWeight"></param>
            <param name="averageLookAtInteractableDuration"></param>
            <param name="averageLookAroundDuration"></param>
            <param name="averageLookAroundVariationDuration"></param>
            <param name="minAngleToPreviousForLookAround"></param>
            <param name="minPitchForLookAround"></param>
            <param name="maxPitchForLookAround"></param>
            <param name="maxYawForLookAround"></param>
            <param name="minAvoidanceAngleForLookAround"></param>
            <param name="durationVariationFactor">Here 1 means no variation; a good value is 1.25</param>
            <param name="timeToFirstVocalization"></param>
            <param name="averagePauseBetweenVocalizations"></param>
            <param name="vocalizationDurationVariationFactor"></param>
            <param name="preferredVocalization"></param>
            <param name="expression"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.LookWatchfullyAndVocalize.Vocalize">
            Subactivities
            <summary>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ActivityT`1">
            <summary>
            This class provides simple functionality to all activities; it's not used for
            polymorphism (thats the role of IXXXActivity)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActivityT`1.UseCog``1">
            <summary>
            NB: this method is here rather than in Mind so it can more easily access 'this' when calling cog.Use(this)
            NB: do not use this method from the constructor of activities, but only from
            either Enter or MainProcess (reason: the cog gets unregistered automatically in Exit)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK">
             <summary>
             Fast full-body IK for a quadruped. This job implements a highly believable as well as fast solution
             to the full-body IK problem for quadrupeds, with several innovative algorithms. It's fast because
             it's non-iterative (not a single for-loop is used) and stateless. Note that it does make assumptions
             about the rig structure. Limb IK is prepared here for both bases and targets, but solved in AnimJobFourLimbIK.
            
             This new version includes limb offset management, which is stateful but only with regard to the limb
             target positions.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.TailSegment">
            <summary>
            Struct that assembles internal information about tail bones
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedLLTargetPos">
            <summary>
            Position of each of the 2/4 limb targets after animation, but before application of 1. grounding, 2. attachment, 3. targeting, 4. touch
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedLRTargetPos">
            <summary>
            Position of each of the 2/4 limb targets after animation, but before application of 1. grounding, 2. attachment, 3. targeting, 4. touch
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedALTargetPos">
            <summary>
            Position of each of the 2/4 limb targets after animation, but before application of 1. grounding, 2. attachment, 3. targeting, 4. touch
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedARTargetPos">
            <summary>
            Position of each of the 2/4 limb targets after animation, but before application of 1. grounding, 2. attachment, 3. targeting, 4. touch
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedS0Pos">
            <summary>
            Same for other body parts;
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedS12Pos">
            <summary>
            Same for other body parts;
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedS3Pos">
            <summary>
            Same for other body parts;
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LastAnimatedHeadPos">
            <summary>
            Same for other body parts;
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.CurrentTensionSqrdLL">
            <summary>
            Properties that indicate the extent to which limb attachment has changed the position of each limb after the last run of this job
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LLGroundingGlobalTargetY">
            <summary>
            At what global Y is the ground for each limb? How this info is used is up to FFBIK.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LRGroundingGlobalTargetY">
            <summary>
            At what global Y is the ground for each limb? How this info is used is up to FFBIK.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ALGroundingGlobalTargetY">
            <summary>
            At what global Y is the ground for each limb? How this info is used is up to FFBIK.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ARGroundingGlobalTargetY">
            <summary>
            At what global Y is the ground for each limb? How this info is used is up to FFBIK.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LLSurfaceNormalForGrounding">
            <summary>
            Surface normals that allow rotating each foot/paw accordingly
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LRSurfaceNormalForGrounding">
            <summary>
            Surface normals that allow rotating each foot/paw accordingly
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ALSurfaceNormalForGrounding">
            <summary>
            Surface normals that allow rotating each foot/paw accordingly
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ARSurfaceNormalForGrounding">
            <summary>
            Surface normals that allow rotating each foot/paw accordingly
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DetachmentStatus">
            <summary>
            Each attachable limb can be in one of three states
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DetachmentStatus.Attached">
            <summary>
            Attached in world-space
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DetachmentStatus.DetachOngoing">
            <summary>
            Detached and freely following or catching up with animated position
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DetachmentStatus.DetachCompleted">
            <summary>
            Detached and freely following the animation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LL_DetachmentStatus">
            <summary>
            Detach status values
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LR_DetachmentStatus">
            <summary>
            Detach status values
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.AL_DetachmentStatus">
            <summary>
            Detach status values
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.AR_DetachmentStatus">
            <summary>
            Detach status values
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Detach_LL">
            <summary>
            Detach values from animated drivers
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Detach_LR">
            <summary>
            Detach values from animated drivers
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Detach_AL">
            <summary>
            Detach values from animated drivers
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Detach_AR">
            <summary>
            Detach values from animated drivers
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.S0LocalTargetOffset">
            <summary>
            'Intentional' limb target offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.S0LocalPoseOffset">
            <summary>
            'Intentional' limb target offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Ts">
            <summary>
            t (interpolation) value for spine interpolation [0 at start, 1 at end]
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.TsSpeed">
            <summary>
            How fast Ts is allowed to move at the moment
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.MinTsSpeed">
            <summary>
            Min/max values for how fast Ts is allowed to move
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.MaxTsSpeed">
            <summary>
            Min/max values for how fast Ts is allowed to move
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.NextSpineEasing">
            <summary>
            Next easing to use to modify spine targets during an ST/OT
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LLNextEasing">
            <summary>
            What easing to use *next* in order to move a given limb to the intended target position/rotation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LRNextEasing">
            <summary>
            What easing to use *next* in order to move a given limb to the intended target position/rotation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ALNextEasing">
            <summary>
            What easing to use *next* in order to move a given limb to the intended target position/rotation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ARNextEasing">
            <summary>
            What easing to use *next* in order to move a given limb to the intended target position/rotation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LLTargetPull">
            <summary>
            How much pull (0..1) each limb should exert on the entire rig during IK solving
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.LRTargetPull">
            <summary>
            How much pull (0..1) each limb should exert on the entire rig during IK solving
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ALTargetPull">
            <summary>
            How much pull (0..1) each limb should exert on the entire rig during IK solving
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.ARTargetPull">
            <summary>
            How much pull (0..1) each limb should exert on the entire rig during IK solving
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.WeightLeftVsRightArmTarget">
            <summary>
            Should arm target weights be lateralized?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.WeightMouthTarget">
            3c. Mouth targeting
            <summary>
            Weight of the mouth target
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.MouthTarget">
            <summary>
            Mouth target in global space (this is the position outside the being that we want the mouth (M, MouthMarker) to reach)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.S0LocalTouchOffset">
            <summary>
            Touch only affects the head-spine chain; these are the individual offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.S12LocalTouchOffset">
            <summary>
            Touch only affects the head-spine chain; these are the individual offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.S3LocalTouchOffset">
            <summary>
            Touch only affects the head-spine chain; these are the individual offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.HeadLocalTouchOffset">
            <summary>
            Touch only affects the head-spine chain; these are the individual offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.WeightTailCorrection">
            <summary>
            Current weight of tail correction, read from animation (DriverInfo_TailIK).
            NB: tail correction allows animations to indicate when the tail is supposed to be connected with the ground
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.WeightHeadPosPreservation">
            <summary>
            Current weight of head position/rotation preservation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.WeightHeadRotPreservation">
            <summary>
            Current weight of head position/rotation preservation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.Time">
            <summary>
            Copies of Time.time and Time.deltaTime
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DeltaTime">
            <summary>
            Copies of Time.time and Time.deltaTime
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.GetLimbTargetOffsets(UnityEngine.Quaternion@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
             <summary>
             Set [L|A][L|R]IntentionalOffset using 'adaptive tweening', which means we use standard easing functions but
             let the t value increase in a robust, adaptive manner. This allows us to deal with the fact that at the beginning
             of a detachment cycle, calculating its duration takes a few frames, and over the course of the cycle, the
             duration may change due to crossfading between root states etc.
            
             This method modifies:
             - XXLocalTargetOffset (clamps them)
             - _XXPreviousLocalTargetOffset
             - XXIntentionalOffset
             - via InterpolateIntentionalLimbTargetOffset:
               - XX_DetachmentStatus
               - all the other fields that relate to intentional offset interpolation
               - most importantly, _XXLocalCurrentOffset, which is what actually gets added to the foot targets
               ==> if there's some negative interaction with GROUNDING in the future, it's by post-processing *this* (and taking
                   into account XX_DetachmentStatus and/or '_XXGroundingDeltaY > 0f') that it can be solved
             - NO transform handle
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.InterpolateIntentionalLimbTargetOffset(VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.DetachmentStatus@,System.Single@,System.Single@,System.Single@,System.Single@,VirtualBeings.Tech.UnityIntegration.Easings.Functions@,VirtualBeings.Tech.UnityIntegration.Easings.Functions@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single@,System.Single@,System.Single@)">
             <summary>
             Decide and handle the actual interpolation of intentional limb offsets during a detachment cycle for one limb.
            
             NB: in contrast to foot-sliding prevention, where the target just tries to catch up with animation during detachment,
             this interpolation uses an easing function and therefore needs to be stateful (to estimate the state of the detachment cycle).
            
             NB: The Detach_LL values are animated and therefore noisy: ideally they would be at 0, then jump to 1 to signal detachment and
             decrease monotonically till they reach 0 again (full attachment). But because of animation blending, crossfades etc
             they may increase initially in several steps and later not decrease steadily but re-increase again.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.FinalizeLimbTargets(UnityEngine.Animations.AnimationStream@,UnityEngine.Quaternion@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
             <summary>
             Carry out foot-sliding prevention and apply it (as well as the 'intentional', i.e. expressive, offsets, and grounding) to the limb targets
            
             This method modifies:
             - the 2/4 foot target transform handles
             - via GetCorrectiveOffsetForLimb():
               - _lastCorrectedLLTargetPos
             - LastAnimatedXXTargetPos
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.UpdateGroundingDeltaYForFoot(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Identical to local function of same name in Actuator.DoGrounding().
            Necessary because it's twin operates with a 1-frame lag, which can cause penetration of limbs into body.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.GetCorrectiveOffsetForLimb(System.Single@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
             <summary>
             Do foot-sliding prevention for a single limb. This changes only XZ coordinates, never Y.
             NB: unlike InterpolateLimbTargetOffset, which also uses detachment values (Detach_XX), here we
             just try to catch up with the animation when we're detached, so we're not really 'stateful' and everything is simpler.
            
             This method modifies:
             - lastCorrectedPos (corresponding to _lastCorrectedXXTargetPos)
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.InterpolateSpineOffsets">
            <summary>
            Update _[S0|S12|S3|Head|HeadRot]LocalCurrentOffset using 'adaptive tweening' (explained below)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.TailCorrection(UnityEngine.Animations.AnimationStream@,UnityEngine.Quaternion)">
            <summary>
            Simple but fast and believable method that makes tail stay in place as much as possible when its parent is moved.
            Produces very good results when tail is on the ground, but shouldn't be used when tail is free (which is the reason why
            _WeightTailCorrection is driven by animation).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.SpinePull(UnityEngine.Animations.AnimationStream@,UnityEngine.Vector3@)">
            <summary>
            Spine pull involves mapping the positional spine offset (S12GlobalTargetOffset) to the torso, using a trigonometric,
            non-iterative approach. Other offsets are handled in the other pulls.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.HeadPull(UnityEngine.Animations.AnimationStream@,UnityEngine.Vector3@)">
            <summary>
            Non-iterative method to make head follow offset without changing position of S3 or shoulders.
            Also makes sure that S3 'follows' Head via rotation, but only as much as given by _WeightS3RotationFollowsH.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.OctolateralPull(UnityEngine.Animations.AnimationStream@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
             <summary>
             'Octolateral' pull allows the four limb effectors to pull the four shoulder/hip effectors and thereby
             (ultimately) S0. This method mostly decomposes the problem into exactly four calls of
             OctolateralPullStep. Decomposing means figuring out the target arm/leg lengths for these steps, letting
             the step affect the shoulder and hip, and re-mapping this result onto S0 (which is the only transform
             affected by this pull).
            
             S0 and S3 offsets are also considered, but of course tightly constrained by their attachment to the legs.
            
             Why 'octo'? Because each leg gets pulled twice.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.BipedPull(UnityEngine.Animations.AnimationStream@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3,UnityEngine.Vector3)">
             <summary>
             Biped pull allows the two limb effectors to pull/push the four shoulder/hip effectors and thereby (ultimately) S0.
            
             In the future: also allow arms to pull/push S0.
            
             S0 and S3 offsets are also considered, but of course tightly constrained by their attachment to the legs.
            
             Effects/side-effects:
             - modifies S0GlobalTargetOffset/S3GlobalTargetOffset (OK because not used afterwards)
             - changes _handle_S0 for both pos and rot
             - changes _handle_H for both pos and rot
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.GetDeltaFromImpactOnSibling(System.Single@,System.Single@,System.Single)">
            <summary>
            For the sibling (say 'R') of a limb (say 'L'), this method takes R's current and max extension, as well
            as the 'target' extension (which is R's hypothetical extension *if* half of L's offset, minus half of
            R's offset, would be applied to R's *base*). Note that this is the extension R would experience in
            OctolateralPullStep() if the delta remained 0.
            The method then compares the impact of the target extension to what's available (as per maxExtension).
            It uses this ratio to map a potentially infinite target extension precisely to the extension that is
            available in this frame.
            The result is that L's impact on R's pull is precisely and smoothely attenuated (it's only pull we're attenuating).
            NB: this method has no side effects.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.GetOffsetPos(System.Single@,System.Single@,UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single)">
            <summary>
            This method uses the same mapping function as GetDeltaFromImpactOnSibling, but this time to attenuate the pull
            on the four hip/shoulder bones that is caused by the torso and spine offsets. Mathematically, in each frame,
            we map the (possibly infinite) pull precisely on the available extension (the delta between current and max).
            We use this to return an adjusted (i.e., shortened) offset vector.
            NB: this method has no side effects.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.OctolateralPullStep(UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single@,System.Single@,System.Single@,System.Single@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single@)">
            <summary>
            One pull iteration moves one of the bases (arms/legs) toward/away from the average delta of the limb effectors
            and lets the respective other base (legs/arms) follow the former
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.MouthTargetPullBiped(UnityEngine.Animations.AnimationStream@)">
            <summary>
            TODO
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobQuadrupedFFBIK.MouthTargetPullQuadruped(UnityEngine.Animations.AnimationStream@)">
            <summary>
            As a final step, pull the mouth (defined by transform handle _M) to a world space position defined by
            MouthTarget (clamped: MT) and weighted according to WeightMouthTarget.
            This algorithm too uses trigonometry and 3D math instead of an iterative approach. The crucial step assumes
            that AT (the weighted average of the arm targets), LT (the same for the legs) and MT are positioned in a manner
            that's 'normal' for a quadruped: such that 'S3toAT x S3toMT' points leftwards from body. The normal defined by
            this product allows us to move S3 on the corresponding plane so as to let M reach MT. This however requires some
            pre- and postprocessing:
            - if MT is 'behind' S3, move torso backwards (like that, S3 never rotates more than 90 degs on up axis)
            - do the same if distance (MT, S3) is smaller than distance (M, S3) (like that, torso is never pushed laterally, only backwards)
            - once S0 has been pushed/pulled via S3, rotate S0 around S3 (!) on the normal defined by S0-S3-LT so that the
              length of the original vector S0-LT remains unchanged
            - ensure that AR0/AL0 aren't being moved with S3 and only slightly follow its rotation
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.AnimJobFourLimbIK">
            <summary>
            Use 3-bone-IK algorithm in one pass on all four limbs.
            Target of each leg is it's respective foot magnet.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobFourLimbIK.ThreeBoneIK(UnityEngine.Animations.AnimationStream@,System.Boolean@,System.Single@,UnityEngine.Animations.TransformStreamHandle@,UnityEngine.Animations.TransformStreamHandle@,UnityEngine.Animations.TransformStreamHandle@,UnityEngine.Animations.TransformStreamHandle@,UnityEngine.Animations.TransformStreamHandle@,System.Single,System.Single,System.Single,System.Single)">
             <summary>
             The basic idea of the algorithm is to treat a 3-bone chain ABCD like a 2-bone chain (ABD) with an extensible/contractable
             2-bone chain (BCD). We first calculate a ratio of how much each of the two chains should contribute to the
             extension/contraction of AD. We then have two cases:
            
             - Case 1), for the hindlegs, cutOffAngleForBone2 is float.MaxValue and hence unused. Here we apply
               the contribution ratio first to BCD by rotating C, apply the rotation limit to C, then
               rotate B to try to cover the remaining extension/contraction of AD, apply the rotation limit to B, and if B got limited,
               take a final pass at rotating and limiting C. In the end, we rotate A to bring D onto or as close to the target as possible.
            
             - Case 2), for the forelegs, cutOffAngleForBone2 is between 0 and the maximum rotation limit. Here we use a heuristic
               approach. Before applying the contribution ratio to BCD by rotating C, we first weigh the contribution so that it gets progressively
               faded out the more stretched out the leg is. We then rotate B as in case 1), but skip the final adjustment pass.
            
             The crucial (but very simple) aspect of the algorithm is the calculation of the ratio; see below.
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobFourLimbIK.AngleFromLength(System.Single,System.Single,System.Single)">
            <summary>
            Uses the law of cosines to calculate the angle (in radians) needed between triangle legs a and b
            so that the third side has length c.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.Ts">
            <summary>
            t (interpolation) value for spine interpolation [0 at start, 1 at end]
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.TsSpeed">
            <summary>
            How fast Ts is allowed to move at the moment
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.MinTsSpeed">
            <summary>
            Min/max values for how fast Ts is allowed to move
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.MaxTsSpeed">
            <summary>
            Min/max values for how fast Ts is allowed to move
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.NextSpineEasing">
            <summary>
            Next easing to use to modify spine targets during an ST/OT
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.AnimJobFloaterFFBIK.InterpolateSpineOffsets">
            <summary>
            Update _[S0|S3|Head|HeadRot]LocalCurrentOffset using 'adaptive tweening' (explained below)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.EarDomainActuator.EarAdditive_DomainStateAction">
            <summary>
            Method that handles requests for ear state changes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.EarDomainActuator.DoAdditiveExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveEarExpression,System.Single,System.Single)">
             TODO : refactor into a full-fledged data-driven state system that supports :
             - absence of ear state (i.e., determined by other animator layers)
             - override states
             - additive states
            
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.#ctor(VirtualBeings.Tech.BehaviorComposition.Being,UnityEngine.Animator,System.Action{VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.PlayableGraphCreateInfos})">
            <summary>
            </summary>
            <param name="being"></param>
            <param name="animator"></param>
            <param name="onPlayableGraphCreated">
            This callback is called each time the playable graph gets (re)created.
            This is where you have to create your anim jobs, and make the connections between them.
            Graph input and output are provided.
            </param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.GetDomainActuator(VirtualBeings.Tech.BehaviorComposition.ActuationDomain)">
            <summary>
            Return the domain actuator as an DomainActuator.
            Returned value can be null if the requested domain has not been registered.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.GetDomainActuator``1(VirtualBeings.Tech.BehaviorComposition.ActuationDomain,``0@)">
            <summary>
            Return the domain actuator as the requested type. The caller is responsible for the compatibility
            in the cast.
            Returned value can be null if the requested domain has not been registered.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.Initialize">
            <summary>
            Must be called by the being after all the domain actuators have been registered.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer.Reset(VirtualBeings.Tech.BehaviorComposition.IRS)">
            <summary>
            Must be called by the being after calling Initialize().
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer._RegisterDomainStateAction(VirtualBeings.Tech.BehaviorComposition.ActuatorStateDomain,System.Func{System.Boolean})">
            <summary>
            Must only be called by DomainActuators.
            Having multiple actions for a single state domain is an error.
            </summary>
            <param name="stateDomain"></param>
            <param name="action"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer._EnsureDomainStateActionIsActive(VirtualBeings.Tech.BehaviorComposition.ActuatorStateDomain)">
            <summary>
            Does what its name says.
            Should only be called by DomainActuators.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.ActuatorContainer._dictDomainControllers">
            <summary>
            Each domain is associated with a Stack of controllers. The topmost item is the only one that actually controls
            the domain. Control-stacks are stored in the following Dictionary.
            NB: this is a dictionary with Domain (cast to int) as key, the cast is cheap and avoids garbage when elements
            are retrieved
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.BodyAdditive_SetParameters(VirtualBeings.Tech.BehaviorComposition.IBodyAttitude,VirtualBeings.Tech.UnityIntegration.Easings.Functions,VirtualBeings.Tech.UnityIntegration.Easings.Functions,System.Single,System.Single,System.Single,System.Single)">
             <summary>
             Called from Actuator.Root_Request* methods (which in turn are called from behaviors), this method sets up the
             actuator variables which will be used by BodyAdditive_Enumerator in order to fade into/out of the correct
             attitude poses or change their weights.
            
             Note that the actual control of if/when to start these changes is taken care of in
             ActivateBodyAdditiveEnumerator() below
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator._ActivateBodyAdditiveEnumerator(VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Boolean,VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Int32,System.Single)">
            <summary>
            This handler is always called at a RS/ST change; it just (re)initializes BodyAdditive_Enumerator
            and ensures that it is ticked from the Actuator via the 'BodyAdditive' domain
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.BodyAdditive_DomainStateAction">
            <summary>
            The domain state action for the BodyAdditive domain simply executes its enumerator method until it's done
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.BodyAdditive_Enumerator(VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Boolean,VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Int32,System.Single)">
            <summary>
            Enumerator that handles the transitioning in/out of body attitude changes (or simple changes of their weights).
            It seems long but has three sequential parts:
            (1) wait until transition in the Animator has started
            (2) configure common parameters
            (3) for both OT and ST, do a single transition of all attitude parameters over the duration of the state
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.BodyAdditive_Enumerator_Helper(System.Int32,System.Single,System.Single,System.Single,VirtualBeings.Tech.UnityIntegration.Easings.Functions,VirtualBeings.Tech.UnityIntegration.Easings.Functions)">
            <summary>
            Specialized helper for BodyAdditive_Enumerator() to handle the parts that are common to actual per-frame
            Attitude transitioning
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.MouthPickup_DomainStateAction">
            <summary>
            NB: this DomainStateAction ensures that _mouthPickup_transitionMethod is moved before returning false
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.MouthPickup_ReleaseHandledInteractable(System.Boolean)">
            <summary>
            Release currently handled interactable from us (if it's still alive). Doesn't make any assumptions about
            interactable still being alive, being handled by us, or having a rigidbody.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.MouthPickup_Enumerator(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean)">
             <summary>
             Pickup-logic such as moving or destroying a handled interactable needs to be done in the Actuator rather
             than in behaviors (like MouthTargeting). The reason is that behaviors might get suspended at any moment.
            
             What happens here is only about the interactable as a function of animated property FBIK_TongueTip:
             handling it, moving it each frame, unhandling or destroying it.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.TransitionToLocalTouchOffsets(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Boolean)">
            <summary>
            NB: the world-space direction of the touch response is set via property SmoothedTouchNormal
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.DoMouthPickup(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean)">
             <summary>
             Schedule a mouth pickup (where an object starts to follow the mouthtarget [instead of the reverse]
             when the animated mouth IK weight is high enough).
             If holdAndDestroy is true, the object isn't simply released (like a ball) but destroyed (like a piece of food).
            
             What happens then is that a DomainStateAction will be started which monitors the animated property FBIK_TongueTip
             to decide 1) when to start handling (and hence moving) the interactable, and 2) when to either unhandle or destroy
             the interactable (the latter if holdAndDestroy is true).
             Nothing else is done by the DSA, no animation or behavior etc is triggered.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.ReleaseMouthPickup">
            <summary>
            Release a mouth pickup that's scheduled or ongoing
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.RenewBodyConfig(VirtualBeings.Tech.BehaviorComposition.BodyConfig@,System.Single,System.Boolean)">
            <summary>
            Allows applying bodyConfig without requesting an RS or an ST. Note that bodyConfig has several Ignore* properties which
            allows certain domains to be unaffected by this call.
            </summary>
            <param name="bodyConfig"></param>
            <param name="transitionDurationOverride">Defines the approximate time over which parameters (IK, attitude) and the new attitude itself are applied.</param>
            <param name="allowReset">If true, allows (if possible) that parametric steering (in Actuator) will be skipped.
            Note that for IK adaptive tweening will always occur, with or without parametric steering.</param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator._ApplyBodyConfig(VirtualBeings.Tech.BehaviorComposition.BodyConfig@,System.Boolean)">
            <summary>
            Apply the data from bodyConfig to the various Transition* methods. Currently only called by
            Root_RequestRS, Root_RequestST and RenewBodyConfig.
            </summary>
            <param name="bodyConfig"></param>
            <param name="allowReset">If true, allows (if possible) that parametric steering (in Actuator) will be skipped.
            Note that for IK adaptive tweening will always occur, with or without parametric steering.</param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.SetBodyPoseOffsetTargets_A(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Used in parallel to the bodyPose/bodyConfig mechanism, 'body pose offset targets' for the spine allow additive changes
            on a per-frame basis to the pose. This is useful for instance when dynamically leaning into a touch and leaves the bodyConfig intact.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.SetBodyPoseOffsetTargets_B(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            See SetBodyPoseOffsetTargets_B. It turns out that multiple mechanisms may want to change
            body pose per-frame at the same time, so now we support two (A and B).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.BodyDomainActuator.TransitionInfo">
            <summary>
            Specialized struct used by BodyAdditive_Enumerator
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.IsInTransitionState">
            <summary>
            Determine if *tag* is stay behavior / transition behavior
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.IsInTransitionStateAndTransitioning">
            <summary>
            Determine if *tag* is stay behavior / transition behavior AND we have
            started transitioning into another state
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.IsFSTAvailableForCurrentFS(VirtualBeings.Tech.BehaviorComposition.IFST)">
            <summary>
            Determine if the current FS supports a given FST
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.Face_DomainStateAction">
            <summary>
            Method that handles requests for facial root state changes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.SetOrTransitionFaceStateTransitionParameters(System.Single,System.Boolean)">
            <summary>
            Called at the beginning of a FS/FST change, this method changes parameters used to configure transitional states;
            it either sets them directly or transitions them by making the Actuator enumerate
            FaceParameterTransitioning_Enumerator() on the 'FaceParameterTransitioning' domain.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.FaceParameterTransitioning_DomainStateAction">
            <summary>
            The domain state action for the FaceParameterTransitioning domain simply executes its enumerator method until it's done
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.FaceParameterTransitioning_Enumerator(System.Single,System.Boolean)">
            <summary>
            See comments for SetOrFadeStateTransitionParameters(). Transitioning is only necessary when a state is being interrupted
            by a FST or FS, which happens rarely. Transitioning always uses Quad interpolation, which does not look good. The only alternative
            would be parametric steering / SmoothDamping, which seems overkill at the moment.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.IsInAnimatedExpression">
            <summary>
            Are we either in an additive expression (yawn, meow etc) or a transition expression (OT or ST)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.IsInAdditiveExpression">
            <summary>
            Is a neck-head-face additive expression (yawn, meow etc) ongoing?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.TerminateOngoingAdditiveExpression(System.Single)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.FaceDomainActuator.DoAdditiveExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Execute an additive neck-head-face expression (yawn, meow etc).
            NB: preferredDuration is a hint, currently used to select different types of meows (animations + vocalizations)
            NB: speed01 is mapped onto a speed multiplier with range [.5 .. 2]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.NotLeggedGroundingDomainActuator.DoGrounding">
             <summary>
             Ground the root and inform the FFBIK job about
            
             TODO maybe better approach in the future, use per-foot movement delta to decide when new raycasts are necessary
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.Root_DomainStateAction">
            <summary>
            Method that handles requests for root state changes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.RootTransitionScheduler_DomainStateAction">
            <summary>
            Enumerates Root_ScheduleRStoRSTransition or Root_ScheduleRStoSTTransition
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.ScheduleRStoRSTransition(VirtualBeings.Tech.BehaviorComposition.RSInfo,VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Int32)">
             <summary>
             In most cases, this enumerator Play()s or CrossFade()s to the desired RS-RS transition. However, if
             the transition has an exit time, then it will monitor the current state on the base layer until that
             exit time has been reached, and only then play the transition.
            
             Once the transition is playing, three types of transitioning are also activated:
            
             - BodyAdditive_Enumerator(), which transitions out current Attitude and the new one in
            
             - SetOrTransitionStateTransitionParameters(), which sets (after a Play) or transitions (after a CrossFade)
             all run-time parameters that vary the transition as requested via the initiating behavior
             (rather than the transitioninfo)
            
             - ParameterInfo handlers, which belong to *states* (rather than transitions) and are used to configure them
               (and it is up to the handlers to decide whether to set or to transition the relevant parameters).
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.ScheduleRStoSTTransition(VirtualBeings.Tech.BehaviorComposition.RSInfo,System.Int32)">
            <summary>
            This enumerator is very similar to Root_ScheduleRStoRSTransition(); see comments there.
            The only real difference is that ST cannot have expressive variations (those would simply be different ST).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.ScheduleTransitionHelper_IsPlayable(System.Single,System.Single,System.Single)">
            <summary>
            Specialized helper for Root_ScheduleRStoRSTransition/Root_ScheduleRStoSTTransition that robustly tests if
            the exit time of a transition has been reached
            </summary>
            <param name="E">Exit time</param>
            <param name="C">Current time</param>
            <param name="L">Last time</param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.SetOrTransitionStateTransitionParameters(System.Single)">
            <summary>
            Called at the beginning of a RS/ST change, this method changes parameters used to configure transitional states; it either sets
            them directly or transitions them by making the Actuator enumerate RootParameterTransitioning_Enumerator() on the 'RootParameterTransitioning' domain.
            Transitioning is necessary when an ST/RS is transitioned to using CrossFade rather than Play.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.RootParameterTransitioning_DomainStateAction">
            <summary>
            The domain state action for the RootParameterTransitioning domain simply executes its enumerator method until it's done
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.RootParameterTransitioning_Enumerator(System.Single)">
            <summary>
            See comments for SetOrFadeStateTransitionParameters().
            Transitioning is only necessary when a state is being interrupted by a ST or RS, which happens rarely.
            Transitioning always uses Quad interpolation, which does not look good. The only alternative
            would be parametric steering / SmoothDamping, which seems overkill at the moment.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.MoveSpeed_CalculateDesiredUrgencyFactor(System.Single,System.Single)">
             Helper methods that provide information but don't change state
            
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.IsInSTC">
            <summary>
            This is the precise criterion for ongoing STC execution.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootDomainActuator.ExtendValidityOfOngoingSTC">
            <summary>
            Extends an ongoing STC by a 'small' amount (e.g., .25s)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.TailDomainActuator.TailAdditive_DomainStateAction">
            <summary>
            Method that handles requests for tail state changes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.TailDomainActuator.TransitionToAngle(System.Single,System.Single)">
            <summary>
            Angle parameter **must** be normalized to the [-1 1] range.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Being">
            <summary>
            A Being is the main component of KuteEngine.<br/>
            It represent a living being with advanced IA (represented as Activities and Behaviors),
            with fully dynamical body animation (represented as Actuator).<br/>
            <br/>
            Spawn a Being using BeingManager.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.SecondaryVocalizationStatus">
            implementation of vocalization logic
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.GetExpressionDataWithOptionalVocalization(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32@,System.Single@,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.AcceptTouchThisFrame">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.UpdateTouchData(VirtualBeings.Tech.UnityIntegration.IAgent,VirtualBeings.Tech.UnityIntegration.IInteractable,UnityEngine.Collider,System.Single,VirtualBeings.Tech.Utils.Set{UnityEngine.Collider},System.Single@,System.Single@,System.Boolean@)">
            <summary>
            Called by a touching interactable (such as a virtual hand) per frame to inform the being about the touch.
            </summary>
            <param name="agent">Which agent is ultimately responsible for the touch?</param>
            <param name="source">What interactable is responsible (e.g. a hand)</param>
            <param name="touching">The collider on <paramref name="source"/></param>
            <param name="maxRadiusOfTouchingCollider">What is the *visual* maximum radius of the touching collider? This is subtracted from the actual
            interpenetration depth of the two colliders to determine if a touching collider is visually inside or outside the being.</param>
            <param name="setTouched">A set of all colliders touched on this being</param>
            <param name="displacement01">Out parameter to tell the touching object how far it displaces the agent (normalized).
            This is useful on touchscreen devices where touch pressure or depth isn't available.</param>
            <param name="penetration01">Out parameter to tell the touching object how far it penetrates into the being (normalized).
            Note that a value above 0 implies that <paramref name="displacement01"/> has reached 1.</param>
            <param name="flagPenetration">Whether a threat event was posted internally due to ongoing penetration</param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Being.NetworkMode">
            <summary>
            Mode the describe how the being is spawned (using network or not)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.HasAuthority">
            <summary>
            Does the current instance has authority over this being ? (Usually yes on Local or Host mode)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.GetNearestPointOnSurface(UnityEngine.Vector3)">
            <summary>
            Very inefficient method, uses linear search over all colliders, use sparingly
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.InitializeAnimationStateSpecific">
            <summary>
            Specific initialization of the being's animation state (RootState, FacialRootState, StateTransition, ...).<br/>
            Each implementation of Being (bird, cat, dog, ...) need to implement this specifically because we cant know beforehand
            which animation state there will be for the specific type of being.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.InitializeBeing(VirtualBeings.Tech.ActiveCognition.BeingData,VirtualBeings.Tech.ActiveCognition.BeingSettings,VirtualBeings.Tech.ActiveCognition.BeingSharedSettings,VirtualBeings.Tech.UnityIntegration.NavigableTerrainManager.Settings)">
            <summary>
            Initialize the being with the given Data and Settings (either on creation or when deserializing when loading a save)
            </summary>
            <param name="beingData"></param>
            <param name="beingSettings"></param>
            <param name="beingSharedSettings"></param>
            <param name="terrainSettings"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.InitializeBeingSpecific">
            <summary>
            Specific initialization for each implemented Being (cat, bird, dog, ...).
            Called after InitializeBeing()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.StartBeing(VirtualBeings.Tech.BehaviorComposition.ExecutionType,VirtualBeings.Tech.BehaviorComposition.Being.NetworkMode,VirtualBeings.Tech.Network.NetworkInterface)">
            <summary>
            Start the Being with the given network mode (Host, Client, Local) and optionally a network interface if the mode is Host or Client.<br/>
            It will create the being's Actuator and optionally create the Mind Activity of the being (if Host or Local, but not on Client).
            </summary>
            <param name="executionType"></param>
            <param name="networkMode"></param>
            <param name="networkInterface"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.CreateActuator(VirtualBeings.Tech.BehaviorComposition.Being.NetworkMode,VirtualBeings.Tech.Network.NetworkInterface)">
            <summary>
            Instantiate and initialize the being's Actuator based on the network mode of the being.<br/>
            If being is spawned on Host or Client, it need a <see cref="T:VirtualBeings.Tech.Network.NetworkInterface"/>.
            </summary>
            <param name="networkMode"></param>
            <param name="networkInterface"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.StartMindBeing(VirtualBeings.Tech.BehaviorComposition.ExecutionType,VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Start the lifecycle of the being as in, start the activities and the behavior of the being.
            Must be called ONLY on the device that has authority over it (call it when we are the server/host, but never if we are the client)
            </summary>
            <param name="executionType"></param>
            <param name="target"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.RSNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IRS"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.STNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IST"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.TransitionTypeDefault">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.ITransitionType"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.USTNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IUST"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.BodyAttitudeNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IBodyAttitude"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.FSNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IFS"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.FSTNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IFST"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.FSTransitionTypeDefault">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IFTT"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.AdditiveExpressionNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.AdditiveEarExpressionNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveEarExpression"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.AdditiveEarStateNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveEarState"/> from server code
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.AdditiveTailExpressionNone">
            <summary>
            Use this property as a *seed* to construct any <see cref="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveTailExpression"/> from server code
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.IsReachableByMouthIK(UnityEngine.Vector3,System.Single)">
            <summary>
            If multiplier01 is smaller than 1, it means that the position needs to be correspondingly closer to the mouth target to be considered reachable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Being.IsStarted">
            <summary>
            Is this being is initialized and started on the current context ?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.IsInPlayerArea(System.Single)">
            <summary>
            Determine if being is inside player area and
            - if margin is positive: at least 'margin' inside of it;
            - if margin is negative: at most '-margin' away from it
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.ReceiveCommunicativeActFromOther(VirtualBeings.Tech.UnityIntegration.AgentEvent_CommunicativeAct)">
            <summary>
            Should only be called from another Being
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.SetRelationship(VirtualBeings.Tech.BehaviorComposition.Being,System.Boolean)">
            <summary>
            Called by other beings when this one is instantiated
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Being.GetSocialDominance01">
            <summary>
            Performance schematic dominance arbitration (based on Age, Dominance01 and Neuroticism01)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.DoArmIK">
            <summary>
            This is a hack to switch between bipeds like birds and quadrupeds.
            Hopefully this should be removed at some point o/
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.RenewBodyConfig(VirtualBeings.Tech.BehaviorComposition.BodyConfig@,System.Single,System.Boolean)">
            <summary>
            Allows applying bodyConfig without requesting an RS or an ST.
            Note that bodyConfig has several Ignore* properties which
            allows certain domains to be unaffected by this call.
            </summary>
            <param name="bodyConfig"></param>
            <param name="transitionDurationOverride">
            Defines the approximate time over which parameters (IK, attitude)
            and the new attitude itself are applied
            </param>
            <param name="allowReset">
            If true, allows (if possible) that parametric steering (in Actuator) will be skipped.
            Note that for IK, adaptive tweening will always occur, with or without parametric steering.
            </param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.DoMouthPickup(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean)">
             <summary>
             Schedule a mouth pickup (where an object starts to follow the mouthtarget [instead of the reverse]
             when the animated mouth IK weight is high enough).
             If holdAndDestroy is true, the object isn't simply released (like a ball) but destroyed
             (like a piece of food).
            
             What happens then is that a DomainStateAction will be started which monitors the animated property
             FBIK_TongueTip to decide
             1) when to start handling (and hence moving) the interactable
             2) when to either unhandle or destroy the interactable (the latter if holdAndDestroy is true).
             Nothing else is done by the DSA, no animation or behavior etc is triggered.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.ReleaseMouthPickup">
            <summary>
            Release a mouth pickup that's scheduled or ongoing
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator._ApplyBodyConfig(VirtualBeings.Tech.BehaviorComposition.BodyConfig@,System.Boolean)">
            <summary>
            Apply the data from bodyConfig to the various body Transition* methods.
            Currently only called by Root.RequestRS, Root.RequestST and Body.RenewBodyConfig.
            </summary>
            <param name="bodyConfig"></param>
            <param name="allowReset">
            If true, allows (if possible) that parametric steering (in Actuator) will be skipped.
            Note that for IK, adaptive tweening will always occur, with or without parametric steering.
            </param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.SetBodyPoseOffsetTargets_A(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Used in parallel to the bodyPose/bodyConfig mechanism, 'body pose offset targets' for the spine allows
            additive changes on a per-frame basis to the pose. This is useful for instance when dynamically leaning
            into a touch and leaves the bodyConfig intact.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IBodyActuator.SetBodyPoseOffsetTargets_B(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            See _SetBodyPoseOffsetTargets_A.
            It turns out that multiple mechanisms may want to change body pose per-frame at the same time,
            so now we support two (A and B).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.DomainActuator">
            <summary>
            The interface needed to be implemented by each Domain Actuator,
            in order for it to be registerable in the Actuator Container.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.DomainActuator.PreUpdate">
            <summary>
            Called at the very beginning of the container's update, can be used to save a state for example.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.DomainActuator.Update">
            <summary>
            Called by the container after the inactive state control actions have been cleaned up and the steering
            have been updated. Can be used to configure IK jobs for example..
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.DomainActuator.PostUpdate">
            <summary>
            Called by the container at the end of the update function.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.DomainActuator.OnPlayableGraphDestroyed">
            <summary>
            Called before the Actuator Container's Playable Graph gets destroyed.
            Used to cleanup anim job data, etc
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IFaceActuator.IsInAnimatedExpression">
            <summary>
            Are we either in an additive expression (yawn, meow etc) or a transition expression (OT or ST)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IFaceActuator.IsInAdditiveExpression">
            <summary>
            Is a neck-head-face additive expression (yawn, meow etc) ongoing?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IFaceActuator.TerminateOngoingAdditiveExpression(System.Single)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IFaceActuator.DoAdditiveExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Execute an additive neck-head-face expression (yawn, meow etc).
            NB: preferredDuration is a hint, currently used to select different types of meows
            (animations + vocalizations)
            NB: speed01 is mapped onto a speed multiplier with range [.5 .. 2]
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IGroundingActuator">
            <summary>
            Reminder that grounding has three parts:
            1. Animated limb-ends getting pulled/pushed to animated limb targets. This happens *always*.
            2. Animated limb targets getting attached to their previous animated world position,
            unless limb/root detach weight is > 0
            3. Animated limb targets getting grounded to the nearest collider below them.
            This is 'grounding' proper and activated by this property.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.INeckAndHeadActuator.DoLookAt(System.Func{UnityEngine.Vector3},System.Single,System.Single,System.Single,System.Single,System.Single,System.Func{UnityEngine.Vector3})">
             <summary>
            
             </summary>
             <param name="globalLookTargetProvider_Head"></param>
             <param name="headWeight">[0,1] Determines how much the head is involved in the LookAt</param>
             <param name="eyeWeight">[0,1] Determines how much the eyes are involved in the LookAt</param>
             <param name="bodyWeight">(Only relevant for humanoids) [0,1] Determines how much the body is involved in the LookAt.
             One should be careful when using high values for the body, as it can end-up with un-natural poses when
             the look target is in "extreme" places (e.g. behind).</param>
             <param name="clampLookWeight">(Only relevant for humanoids) [0,1] 0 means the being in unrestrained in motion.
             1 means the character is clamped (LookAt becomes impossible). 0.5 means the being is able to move on half its
             possible motion range.</param>
             <param name="urgencyFactor01"></param>
             <param name="globalLookTargetProvider_Eye"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IRootActuator.ExtendValidityOfOngoingSTC">
            <summary>
            Extends an ongoing STC by a 'small' amount (e.g., .25s)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IRootActuator.IsInTransitionStateAndTransitioning">
            <summary>
            Determine if *tag* is stay behavior / transition behavior AND we have
            started transitioning into another state (used by MoveTo)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IRootActuator.IsSTAvailableForCurrentRS(VirtualBeings.Tech.BehaviorComposition.IST)">
            <summary>
            Determine if the current RS supports a given ST
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IRootActuator.GetMaxDistanceForTransitionType(VirtualBeings.Tech.BehaviorComposition.IRS,VirtualBeings.Tech.BehaviorComposition.IRS,VirtualBeings.Tech.BehaviorComposition.ITransitionType)">
            <summary>
            Given a current RS and a requested RS, what is the maximum distance an OT of type transitionType
            might displace the root?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IFlyActuator.CurrentTimePassedTakingOff">
            <summary>
            Current time passed since the start of the transition from STAND to either FLY or HOVER.
            The time passed is calculated at the frame where the feet are detached from ground.
            Used for direction calculation inside TakeOff
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ServiceActivity">
            <summary>
            Service Activities provide a common set of functionnalities to be used by any Being.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ServiceActivity.PostUpdate">
            <summary>
            Ticks the Update()s of our Behaviors, then defers to base.PostUpdate()
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Fly.Target">
            <summary>
            The current target of the bird (position in air, land position in ground, ...)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.ObstacleDetector">
            <summary>
            Component that allow to store obstacle near the Being in real-time
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Fly.DEBUG_LastRequestedFly">
            <summary>
            Last request fly made to this behavior. Only used for debug.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Fly.CurrentState">
            <summary>
            Current flying state of the being.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.FlyState">
            <summary>
            Describe the different possible state that a flying being can be in.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.ChunkPathFinding">
            <summary>
            Component that allow to create a path between chunks. Used by some FlyType and FLyService
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Fly.SteeringVelocity">
            <summary>
            Velocity that's due to steering (on top of animation)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.DEBUG_CurrentFlyBrick">
            <summary>
            Current Fly Type that is playing. Used for debug.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Request``1(``0)">
            <summary>
            Request this Fly Behavior to execute a specific FlyBrick, given the FlyBrickData corresponding.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="flyBrickData"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.IsRequestComplete">
            <summary>
            Is the last request completed ? Use this to stop before yielding a frame for nothing when the Process is done. <br/>
            We check if the last children is done, before this children is stopping itself,
            because it will yield a frame.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.ResetSteering">
            <summary>
            Reset all steering parameters (used when the bird is grounded)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.SetTargetRotation(UnityEngine.Quaternion)">
            <summary>
            Set current targetRotation. Used when starting to use FlyToTarget()
            </summary>
            <param name="targetRotation"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.FlyToTarget(UnityEngine.Vector3,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Set a target position for the being the fly to, using steering algorithm to translate and rotate mid-air.
            </summary>
            <param name="targetPoint"></param>
            <param name="steeringAccelerationUrgency01"></param>
            <param name="velocityAcceleration01"></param>
            <param name="angularAcceleration01"></param>
            <param name="allowUpsideDown"></param>
            <param name="useVariation"></param>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly._setVelocityThisFrame">
            <summary>
            Do we apply a given velocity this frame for the being translation, insted of giving it a target ?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly._flyBrickEnumerator">
            <summary>
            Enumerator for current fly brick
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly._requestedFly">
            <summary>
            Current requested Fly
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.TargetData">
            <summary>
            A Target define an abstraction of a Target, be it a position in the ground or in air, with a given state..
            TODO : extend its functionnality
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.IFlyBrick">
            <summary>
            Interface to be able to get all the FlyService of a FlyType. (mainly used for debug)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.IFlyBrickData">
            <summary>
            Struct data that should encapsulate a specific FlyBrick's data
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyBrick">
            <summary>
            A <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyBrick"/> is a "brick" component that define the way that a being move when flying.<br/>
            Fly bricks are not compositional (they cannot contain other fly bricks). Instead, composition is carried out by activities that use <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly"/>.<br/>
            It will use, control, and order one or multiple <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1"/>. <br/>
            Example:<br/>
            - Land<br/>
            - FlyZigZag<br/>
            - TakeOff<br/>
            - ....<br/>
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyBrick._fly">
            <summary>
            Fly (behaviour) that should be the parent of this FlyType process.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.FlyTo">
            <summary>
            Flight describing the being motion to fly through the map between chunks if needed, and aim to land in a given position.
            Must face the landing position to end itself !
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.Hover">
            <summary>
            Flight describing the being motion to fly through the map between chunks if needed, and aim to land in a given position.
            Must face the landing position to end itself !
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Hover.FlyToHoverPosition">
             <summary>
             We want to reach the "target" defined by the nearest point on the surface of the sphere,
             defined by center = HoverPosition ; and radius = MaxDistanceToHoverFromCenter,
             with a velocity of "MaxHoverVelocityOutsideSphere".
            
             If we are too far, we accelerate toward the Target.
             Else, we slow down toward it, so that once we reach it, we exaclty have the desired velocity.
            
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Hover.FlyWhileAccelerating(UnityEngine.Vector3)">
            <summary>
            Accelerate toward target while Flying.
            </summary>
            <param name="toTarget"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Hover.ClampDirectionAngleUpAxis(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Clamp a direction from Vector3.up axis.
            TODO : need to add it to misc to be accessible to all Fly Bricks
            </summary>
            <param name="directionToClamp"></param>
            <param name="directionToClampFrom"></param>
            <param name="maxAngle"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Land.MainProcess">
             <summary>
             TODO :
             - Add LandDirection follow being forward, with certitude that we have it at the end of land (even if up or bottom)
             - If perch, calculate LandDIrection with the given oritention (multiply quaternion calculated with vector.right ?)
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.Pivot">
            <summary>
            Flight describing the being motion to fly through the map between chunks if needed, and aim to land in a given position.
            Must face the landing position to end itself !
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.Pivot.MainProcess">
            <summary>
            TODO :
            - HOver to pivot : bug transition rotation (y up, centripetal)
            - Pivot "looping" not realistic, must be like an ellipse (accelerate, slow down top, and get speed when going down)
            - Looping bug when doing 1,25 loop (barrel roll) -> centripetal force bug
            - Landing fix : if start landing as hovering (no velocity) he should build up speed (with transition animation too) then slow down at the end, not constant speed
            - Hover : add left/right, Down/up
            - hover : add head tilt ? Rotation ?
            </summary>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1">
            <summary>
            A <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1"/> describe a specific part of a fly type. It should describe a specific way of flying. <br/>
            To do that, a FlyService need to be initialized (see <see cref="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.InitializeSpecific"/>) with a <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.IFlyServiceData"/> object. <br/>
            Then, it need to calculate a <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.FlyData"/> object (see <see cref="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.ComputeSpecific"/>) that contain a force to apply to the being who is flying. <br/>
            Example :<br/>
            - TakeOff<br/>
            - Land<br/>
            - Avoid obstacle<br/>
            - Follow path<br/>
            - ... <br/>
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.lastFlyData">
            <summary>
            Last FlyData that was computed by this service.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.data">
            <summary>
            Data given at initialization that allow to compute this service.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.Initialize(`0)">
            <summary>
            Initialize this FlyService with specific Data for this service to be able to compute a <see cref="T:VirtualBeings.Tech.BehaviorComposition.Fly.FlyData"/> result.<br/>
            A FlyService must be initialized before computing !
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.Compute">
            <summary>
            Given the data at initialization, compute the different forces that should impact the velocity of the being.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.ComputeSpecific">
            <summary>
            Given the data at initialization, compute the different forces that should impact the velocity of the being.<br/>
            Each implemented service should compute it's own forces based on it's role (Avoid collider ? Follow a Path ? ...)
            </summary>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.AFlyService`1.InitializeSpecific">
            <summary>
            If there is a need to give specific instructions when initializing this FlyService when receiveing FlyServiceData at initialization, override this method.<br/>
            This method is optionnal.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.IFlyServiceData">
            <summary>
            Data that should contains all necessary data for a FlyService to compute.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.FlyData">
            <summary>
            Struct containing all the necessary data to apply a force for a flying being.
            It describe the direction and magnitude of the force, and an influence for the given direction.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.AvoidanceService">
            <summary>
            FlyService that allow to avoid obstacle close to the being, by calculating an opposite direction for each colliders.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.AvoidanceService.ComputeSpecific">
             <summary>
             Use 2 cone : small and big, to calcul avoidance of collider found inside the sphere (collidertrigger).
             Check the closest position from bird to collider
             If inside small cone , use it for direction and acceleration avoidance
             If Outside small cone but inside big cone :
             - Project it toward limit of small cone. If we stil touch the same collider , we consider it as a collider inside small cone
             - Else, only use it for direction avoidance (maybe a little acceleration ?)
            
             - Always assume that we use path finding, so we dont fly towards walls
             </summary>
             <returns></returns>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.AvoidanceData.MinAngleMaxAvoidance01">
            <summary>
            Minimum angle compared to the beings's forward, where the collider is considered as max threat to avoid.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.AvoidanceData.MaxBackDistance">
            <summary>
            Max distance at the back of the being, where we consider the collider to avoid (from 0 to this value).
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.AvoidanceData.MinDotFront01">
            <summary>
            Min Dot value (0 ; 1) to consider the collider in front of us
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Fly.PathFollowService.ComputeSpecific">
            <summary>
            Each time we compute this service, we store the last current path in the parameter <see cref="P:VirtualBeings.Tech.BehaviorComposition.Fly.PathFollowService.currentPath"/>, so that when we re-call this function,<br/>
            we dont start from the initial path, but the last one that we stored.<br/>
            <br/>
            It means that, even if we dont re-compute the path and initialize this service with a new path, meaning that we only created a Path one time at the beginning and never after,<br/>
            we wont ever follow a previously passed chunk path. Once a chunk is passed, it is passed. We can only go forward to find the current path which the being must follow.<br/>
            <br/>
            Of course, if we re-compute a new Path (from the current being position to the goal position), the new path will be composed of previously passed chunk. We start fresh in this case !
            </summary>
            <returns></returns>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.PathData.weightFacingWindows">
            <summary>
            Weight for direction to windows center, when the being is already facing the windows
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Fly.PathData.weightNotFacingWindows">
            <summary>
            Weight for direction to windows center, when the being is not facing the windows
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Fly.WanderService">
            <summary>
            Wander in the open space.
            Choose a chunk randomly ?
            GO to this chunk
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.FSInfo">
            <summary>
            Class instantiated and serialized in the Unity editor to provide info about facial states (FS)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.FSTTransitionInfo">
            <summary>
            NB, this struct is not a misnomer, a facial self-transition (FST) can and must also be transitioned into.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveEarExpression">
            <summary>
            IAdditiveEarExpression: interface for additive ear expressions
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveEarState">
            <summary>
            IAdditiveEarState: interface for additive ear states
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression">
            <summary>
            IAdditiveExpression: interface for additive neck-head-face expressions (which are orthogonal to the FSS)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IAdditiveTailExpression">
            <summary>
            IAdditiveTailExpression: interface for additive tail expressions
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IBodyAttitude.Wideness">
            <summary>
            Returns 0 == curled in or drawn in, 1 == neutral, 2 == stretched out, 3 == very stretched out
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.IBodyAttitude.Hash">
            <summary>
            Hash of this attitude in the animator controller asset
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.IFSEnums.None">
            This is set in stone: there are exactly 7 basic expressions, for any virtual being.
            This is based on ideas by sociologist J. Turner, who finds that many 'subtle'
            emotions can be expressed by a primary/secondary pair of the following 7.
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IFS">
            <summary>
            IFS: interface for facial states
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IFST">
            <summary>
            IFST: interface for self-transitions between FS
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IFTT">
            <summary>
            IFTT: interface for transitions between FS
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IRS">
            <summary>
            IRS: interface for root states
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IST">
            <summary>
            IST: interface for self-transitions between RS
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ITransitionType">
            <summary>
            ITransitionType: interface for transitions between RS
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.IVocalAnimationList.GetRandomVocalAnimation(System.Single)">
            <summary>
            Returns a random VocalAnimation whose DefaultDuration is 'probably' not
            too far from preferredDuration, though this is not guaranteed.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper">
            <summary>
            Struct used inside activities and behaviors to parameterize and use facial states using the IFS interface
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.Type">
            <summary>
            The 'nominal' FS of this expression
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.ConcreteType">
            <summary>
            The 'actual' (i.e., animated) FS of this expression. Usually identical to Type, but
            can be overridden by calls to the Self.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.SecondaryType">
            <summary>
            The secondary FS 'colors' Type. Mainly useful via calls to Self in order to set ConcreteType.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.RequestedTransitionType">
            <summary>
            If ConcreteType is not yet the current FS, how should it be reached (via which FOT) ?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.Intensity01">
            <summary>
            All FS have an intensity from 0 to 1. At 0 they're identical to 'None'.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.Randomization01">
            <summary>
            Tells behaviors how much to randomize the actual intensity of this state.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.Vivacity">
            <summary>
            How 'vivacious' is this expression? (.5 == neutral)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.VivacityWeighted">
            <summary>
            Vivacity weighted by Intensity
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.HasConcreteType">
            <summary>
            As a key feature of the personality system, more 'generic' expressions such as HAPPY can
            be overridden (ideally via service methods in the Self) by more concrete expression (such as HappyInnocent).
            This should only be taken into account by the Self and is therefore hidden from other parts of the AI.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.ResetConcreteType">
            <summary>
            Revert ConcreteType back to Type.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper.SetConcreteType(VirtualBeings.Tech.BehaviorComposition.IFS)">
            <summary>
            Set by Self to account for 1) secondary expression, 2) the being's personality and 3) any contextual factors.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.RSInfo">
            <summary>
            Class instantiated and serialized in the Unity editor to provide info about root states (RS)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RSTransitionInfo.#ctor(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Only this constructor should be used
            </summary>
            <param name="hash">Hash of the transition state in the animator controller</param>
            <param name="transitionType">Type of the OT as indexed by ITransitionTypeEnums or by client-side ID</param>
            <param name="crossFadeDuration">If greater than 0, do a crossfade (using normalized time) instead of an instant transition</param>
            <param name="transitionOffset">At which point in the target state (using normalized time) should we start the transition?</param>
            <param name="exitTime">Normalized exit time. If negative, owning RS can be exited at any time</param>
            <param name="nextExpressiveVariation">If >= 0, refers to index of RSTransitionInfo</param>
            <param name="nextExitTimeVariation">If >= 0, refers to index of RSTransitionInfo; in that case, TransitionType of the referenced RSTransitionInfo is ignored</param>
            <param name="maxDistance">If this OT is used, by how much could it move the root? (this serves as a filter against OTs that risk collisions)</param>
            <param name="maxAngle">If this OT is used, how far does it allow the root angle to be turned via steering? (this serves as a filter against OTs)</param>
            <param name="maxCrossFadeDurationOfTransitionParameters"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.STTransitionInfo">
            <summary>
            NB, this struct is not a misnomer, a self-transition (ST) can and must also be transitioned into. Often this will
            be instantaneous (using Play()) but sometimes will require a Crossfade().
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.STTransitionInfo.#ctor(System.Int32,System.String,System.Single,System.Single,System.Boolean,System.Single,System.Int32,VirtualBeings.Tech.UnityIntegration.Easings.Functions,System.Single)">
            <summary>
            Only this constructor should be used
            </summary>
            <param name="hash">Hash of the transition state in the animator controller</param>
            <param name="name">Name of the State inside the animator controller</param>
            <param name="crossFadeDuration">If greater than 0, do a crossfade (using normalized time) instead of an instant transition</param>
            <param name="transitionOffset">At which point in the target state (using normalized time) should we start the transition?</param>
            <param name="isUninterruptible"></param>
            <param name="exitTime">Normalized exit time. If negative, owning RS can be exited at any time</param>
            <param name="nextExitTimeVariation">If >= 0, refers to index of STTransitionInfo</param>
            <param name="suppress">Curve that determines how much the current BA should be suppressed over the course of the ST</param>
            <param name="maxCrossFadeDurationOfTransitionParameters"></param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ExecutionType">
            <summary>
            Don't change order / numbers
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.BodyResetType">
            <summary>
            Used by CatBodyConfigBehavior, defines how to (re)set a new/ongoing BodyConfig
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.BodyConfig">
            <summary>
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.LL">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.LR">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.AL">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.AR">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.S0">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.S12">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.S3">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.Head">
            <summary>
            Local positional offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.HeadRot">
            <summary>
            Local rotational offset for head. Useful because it is interpolated via BodyConfig (thus synced with
            attitude-transport etc.) but applied via Neck-Head-IK (which also means that it requires LookAt).
            Note that this means that it is subjected to neck-head-weight (set by LookAt etc).
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.UrgencyFactor01">
            <summary>
            NB: this uf is only used when moving an offset target *during* an ongoing interpolation;
            the speed of the interpolations themselves is always driven by animation
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.MinTsSpeed">
            <summary>
            These are the min/max speeds at which FFBIK augments the unitless Ts value, which is used to interpolate spine offsets
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.BodyConfig.MaxTsSpeed">
            <summary>
            These are the min/max speeds at which FFBIK augments the unitless Ts value, which is used to interpolate spine offsets
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.LeggedGroundingDomainActuator">
            <summary>
            Reminder that grounding has three parts:
            1. Animated limb-ends getting pulled/pushed to animated limb targets. This happens *always*.
            2. Animated limb targets getting attached to their previous animated world position, unless limb/root detach weight is >0
            3. Animated limb targets getting grounded to the nearest collider below them. This is 'grounding' proper and activated by this property.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LeggedGroundingDomainActuator.DoGrounding">
             <summary>
             Ground the root and inform the FFBIK job about
            
             TODO maybe better approach in the future, use per-foot movement delta to decide when new raycasts are necessary
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior">
             <summary>
            
             This Behavior never plays any animations, the only thing it does is per-frame updates to Actuator.Body_MouthTarget.
            
             Via these, the Behavior allows any animation (whether it's an attitude or an additive neck-head-face animation)
             to use animated property FBIK_TongueTip to connect the bone 'mouth_target' with a TargetFunc or a TargetIInteractable.
            
             Alternatively, activities can also call ForceTargeting() to achieve the same thing without relying on FBIK_TongueTip.
            
             How this works:
             - pickup animations can be STs or NeckHeadFaceAdditive
             - they need to define animation events (see PostProcessAnimation.cs)
             - by calling DoTargeting(), activities make the being *ready* for mouthtargeting, but an ST or NeckHeadFaceAdditive
               that animates the tonguetip-IK weight needs to be called *separately*
             - alternatively, via ForceTargeting, this animation isn't needed
            
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.TargetFunc">
            <summary>
            Change target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.TargetIInteractable">
            <summary>
            Change target (can be null)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.UseVelocityBasedTargetCorrection">
            <summary>
            Only set to true if ForceTargeting() isn't also used (or just was, or will be)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.DoTargeting(System.Boolean,System.Boolean)">
            <summary>
            Use this after having set TargetFunc or TargetIInteractable. If we're Active *and* TargetIInteractable has been set *and*
            pickup is true, then this will also tell the Actuator to attempt *one* mouth-pickup.
            Otherwise (or if failed) the pickup is lost (i.e., it won't be reattempted automatically).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.ForceTargeting(System.Single,System.Single,System.Func{System.Boolean})">
            <summary>
            Use this after having set TargetFunc or TargetIInteractable.
            Unlike DoTargeting, this doesn't set up any mouth pickup and can therefore be used repeatedly (to adjust forced IK or UF)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.ReleaseForcedTargeting(System.Single)">
            <summary>
            Actually just a wrapper to ForceTargeting(0f, ...)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MouthTargetingBehavior.UpdateMouthTarget(System.Boolean)">
            <summary>
            Arbiter method.
            - This is the only place where _targetFunc/_targetIInteractable are evaluated.
            - This is the only place where Actuator.Body_MouthTarget is set.
              Here velocity based target correction is optionally used.
            </summary>
            <returns>False if there is no valid target (forcing MT to end), true otherwise.</returns>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1">
             <summary>
             This abstract class replaces Behavior as a superclass for Behaviors such
             as Stay and MoveTo that give access to BodyConfig and root-parenting.
            
             The basic idea is to capitalize on the fact that Behaviors are always owned by
             Activities. It therefore makes sense to never (or rarely) let A's instantiate BodyConfig
             (which is large and unwieldy) but keep BodyConfigBehavior as a single source of truth.
            
             In sum, A's get direct writing access to the B's BodyConfig, which passes it by ref to
             the Actuator whenever it wants to have its values applied.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.CancelRootParenting">
            <summary>
            NB: this does *not* have to be called manually by using activities to end root parenting.
            Root parenting is ended automatically as soon as all legs are detached (>0) *after* they
            were attached for at least 1 frame. See Actuator.Grounding.cs
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.DoGrip(System.Single,System.Single,System.Single)">
            <summary>
            TODO generalize, see TailAdditive. Use enum in order to request foot expression /
            configuration based on an extensible enum
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.BodyPoseTransitionDuration">
            <summary>
            The (approximate time) time it will take to change IK target offsets *and* attitude and its parameters.
            NB: I wish I wouldn't have to expose this variable because it's not super obvious for outsiders *when*
            it is being used internally, but right now I cannot avoid it.
            The TL;DR is that this defines the duration of a bodypose change (including attitude change) in the absence
            of a ST or OT (i.e., a transition within an RS or between RS').
            Such a bodypose change is always ensured when Stay or MoveTo starts.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.ApplyBodyConfigWithoutST(System.Single)">
            <summary>
            Use this public method from activities in order to apply this behaviors BodyConfig without any ST. Use the BodyConfig's various
            Ignore* properties to selectively affect only certain IK effectors or the attitude. *Can* be called each frame to set IK
            effectors continuously, but in that case BodyConfig.IgnoreAttitude should be set to true.
            </summary>
            <param name="bodyPoseTransitionDuration">How long all transitions should take. If not set, it will be set to DefaultCrossFadeTimeForSTs.
            In any case, this duration always overrides bodyConfig.MinTsSpeed/MaxTsSpeed.</param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.HasLimbTension(System.Single)">
            <summary>
            Determine if any limb currently has an under-transported target offset farther than thresholdDist
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.SetBodyPoseOffsetTargets_A(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Used in parallel to the bodyPose/bodyConfig mechanism, 'body pose offset targets' for the spine allow additive changes
            on a per-frame basis to the pose. This is useful for instance when dynamically leaning into a touch and leaves the bodyConfig intact.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.SetBodyPoseOffsetTargets_B(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Used in parallel to the bodyPose/bodyConfig mechanism, 'body pose offset targets' for the spine allow additive changes
            on a per-frame basis to the pose. This is useful for instance when dynamically leaning into a touch and leaves the bodyConfig intact.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.ResetBodyPoseOffsetTargets_A(System.Single)">
            <summary>
            Reset all 'body pose offset targets' to zero.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.ResetBodyPoseOffsetTargets_B(System.Single)">
            <summary>
            Reset all 'body pose offset targets' to zero.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.ApplyBodyConfig">
            <summary>
            If true, then this behavior will apply the modified BodyConfig when it's ticked.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.RootBehaviorT`1.ApplyBodyPoseOffsetTargets_A">
            <summary>
            If true, then this behavior will apply the modified BodyConfig when it's ticked.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IActivity">
            <summary>
            Here a reminder of why this interface exists: so that specific being-types (birds etc) can provide inheriting interfaces (IBirdActivity etc).
            This is necessary so that specific Mind-Types (BirdMind etc), which have to inherit from Activity via Mind and thus cannot inherit from
            more specific activities (BirdActivity etc), can implement these interface and thereby become the controlling activity for the various
            being-type-specific activities (Blink etc).
            
            Do _not_ use this interface directly, use activities of unknown type via Activity instead
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.IProcess">
            <summary>
            This interface only exists to allow a cast to Process (that I don't know how to avoid)
            in Process.StartInternal()
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Process">
            <summary>
            Base class for all Processes. Use this to create new kinds of Processes, which will
            require implementing MainProcess() and optionally Exit(). In MainProcess() you can start
            nested Processes which will be executed in parallel with your Process. Correct call order is taken care of.
            
            The root Process has to be ticked externally (via IEnumerator returned from public Start()).
            
            Guarantees:
            - Start() is deterministic in both forms, i.e. it cant fail.
            - Interrupt() ensures that the MainProcess won't be called anymore, and that
              the Process will process Exit() and that of its children as soon as it is ticked.
            - Calling Start() after Interrupt() in the same frame 'un-interrupts' the process, i.e. it
              continues execution rather than restarting (this is unavoidable by design).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.StartTopLevel">
            <summary>
            Start a top-level Process and allow it to be enumerated by caller (e.g., via yield).
            NB: This method cannot be used to start Processes inside Processes; use the following Start for that.
            NB: *don't* create new Processes or Behaviors inside the constructor of a Process, but only
            in MainProcess() [reason: Processes are recyclable, but their child Processes get detached from the
            calling framework when Finish is called. New Processes must be called inside the Start() - Finish() cycle]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.StartInternal(VirtualBeings.Tech.BehaviorComposition.IProcess)">
            <summary>
            Start the Process inside another IProcess, which will control its execution
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.StartInternal(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Start the Process inside another Process, which will control its execution
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.StartHelper">
            <summary>
            Carry out tasks common to StartTopLevel and StartInternal
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Interrupt">
            <summary>
            Allow this Process to be interrupted from the inside or outside. At next tick, Exit instead of MainProcess will be called
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Process.Active">
            <summary>
            Check if Process is currently running
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.MainProcess">
            <summary>
            This is the work-horse of all Processes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Enter">
            <summary>
            Use to allocate resources each time before MainProcess actually starts.
            NB: this is always called before MainProcess starts, thus not very useful, but its nice syntactic
            sugar if symmetrical stuff has to happen in Enter()/Exit().
            NB: if this is used to set OnProcessPreTick, then the latter will be called correctly before the first tick of MainProcess
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Exit">
            <summary>
            Because MainProcess() can be cancelled and left dangling at any frame, use Exit() to free up any resources.
            NB, for future reference: Does this really work, is it safe, even for nested subprocesses that got interrupted?
            The answer is YES - IF the process wasn't started and interrupted 'manually', but via the Interrupt() mechanism,
            because this mechanism ensures that all subprocesses terminate *themselves*.
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.BehaviorComposition.Process.Initialize">
            <summary>
            Internal event that's invoked once per process, the first time it is started (right before Enter()).
            NB: why an event instead of a protected virtual method? Because this allows adding a closure to the event in
            the Process's public constructor and feeding in constructor parameters.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.Process.FOREVER">
            <summary>
            Semantic clarification for the 'endless' loops that are often used in MainProcess
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Process.IsInterrupting">
            <summary>
            Accessible from children
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.RegisterChild(VirtualBeings.Tech.BehaviorComposition.Process)">
            <summary>
            Called from Start(Process parent) above
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.BehaviorComposition.Process.OnProcessPreTick">
            <summary>
            Use this to register events to be ticked at each frame before MainProcess is ticked
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.BehaviorComposition.Process.OnProcessPostExit">
            <summary>
            Use this to register events to be called right after Exit()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.ScheduleTask(System.Action,System.Single)">
            <summary>
            Program an Action to be executed in waitTime seconds by OnProcessPreTick
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.ScheduleTask(System.Action,System.Single,System.Single)">
            <summary>
            Program an Action to be executed in between minWaitTime and maxWaitTime seconds by OnProcessPreTick
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.ClearScheduledTasks">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.CheckScheduledTasks">
            <summary>
            Check and execute scheduled tasks
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Update">
            <summary>
            Iterate MainProcess as well as all the Update() methods of our child-processes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.PostUpdate">
            <summary>
            Ensures that the Process and it's children is wound down when interrupted;
            when not interrupted it ensures child Processes that have been interrupted are wound down.
            Returns false if the Process has terminated (either due to external interruption or because its
            MainProcess() has returned false).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Finish">
            <summary>
            Correctly finish operation of this Process and all its descendants
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Process.Ticker">
            <summary>
            This ticker method is only used if this Process has been started without a parent
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Domain">
            <summary>
            Enum of all possible actuation domains for all possible characters; which ones are actually
            used (and which subsets of them are 'disjoint') is defined by subclasses of Behavior etc.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.ActuatorStateDomain">
            <summary>
            NOTE (for anyone who touches this): these domains represent enumerators that are called via a dynamic list
            of domain handlers in the ActuatorContainer. This list should be seen as 'ordered': earlier handlers can
            schedule later handlers but NOT vice versa (otherwise, the same domain may end up being called twice per frame).
            The reason is that new handlers are added sequentially to the dynamic list.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.BlinkBehavior">
            <summary>
            NB: this behavior does not query the Actuator to determine if a blink is currently possible. This means that ongoing
            blinks are immediately interruptible (which is much less problematic than having long uninterruptible blink behaviors).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.TargetProviderHead">
            <summary>
            Define where head 'looks' at (with weight HeadWeight), can be null
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.TargetProviderEyes">
            <summary>
            Define where eyes look at (with weight EyeWeight); can (and often will) be null, in which case head-target will be used
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.HeadWeight01">
            <summary>
            Set extent to which head faces target (from current animated position); NB that the weight is pre-additive-rotations
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.EyeWeight01">
            <summary>
            Set extent to which eyes face target:
            1 == mind's eye looks directly at target in world space (unless its local rotation gets clamped according to actuator parameters);
            0 == mind's eye stays in the rotation it acquired after its animated rotation was rotated with the head (i.e., after both head-lookat and additive head rotation);
            Note that even when weight is 0, eyes will apply additive eye rotation at 100%!
            In both cases, L/R eyes follow mind's eye but keep animated offset to mind's eye.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.EyesClosed01">
            <summary>
            How much eyes should be closed, from 0 (same as base expression) to 1 (eyes closed)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.ConfigureLookStabilization(System.Boolean,System.Single,System.Single,System.Single)">
            <summary>
            Allow the look direction to be 'frozen' until either 1) some time has passed or 2) the angle to look target has changed.
            This achieves look-at patterns that are typical of birds.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.SetCustomUrgencyFactorDeltaNeckAndHead(System.Single)">
            <summary>
            Add a custom delta to urgency factor to slow down or speed up neck/head movements independent
            of current Expression. Must be reset manually.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.IsInAnimatedExpression">
            <summary>
            Are we either in an additive expression (yawn, meow etc) or a transition expression (FOT or FST)?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.IsInAdditiveExpression">
            <summary>
            Is a neck-head-face additive expression (yawn, meow etc) ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.IsInFOTorFST">
            <summary>
            Is a neck-head-face transition expression (FOT or FST) scheduled or ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.IsInFOT">
            <summary>
            Is a neck-head-face FOT scheduled or ongoing?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.IsInFST">
            <summary>
            Is a neck-head-face FST scheduled or ongoing?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoAdditiveExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveExpression,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request a neck-head-face expression (yawn, meow etc)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.TerminateAdditiveExpression(System.Single)">
            <summary>
            Does what it says, but immediately (doesn't wait for Tick)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoMouthOpen(System.Single,System.Single)">
            <summary>
            Open/close the mouth (strictly additive)
            </summary>
            <param name="mouthOpen01"></param>
            <param name="urgencyFactor01"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoHeadLookAtOffsetPitch(System.Single,System.Single)">
            <summary>
            Offset head look direction (after look-at and weight is applied)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoHeadLookAtOffsetYaw(System.Single,System.Single)">
            <summary>
            Offset head look direction (after look-at and weight is applied)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoHeadLookAtOffsetRoll(System.Single,System.Single)">
            <summary>
            Offset head look direction (after look-at and weight is applied)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoEyeLookAtOffsetPitch(System.Single,System.Single)">
            <summary>
            Offset eye look direction (after head as well as eye look-at and weight is applied)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.DoEyeLookAtOffsetYaw(System.Single,System.Single)">
            <summary>
            Offset eye look direction (after head as well as eye look-at and weight is applied)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.ReleaseLookAtOffsets(System.Boolean,System.Boolean)">
            <summary>
            Release head and/or eye look-at offsets
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.#ctor(VirtualBeings.Tech.BehaviorComposition.ServiceActivity,System.Func{UnityEngine.Vector3},System.Single,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper},System.Func{UnityEngine.Vector3},System.Single,System.Single,System.Single)">
            <summary>
            LookAt makes character look at target with a specified expression. It also creates small, realistic variations of the expression
            every few seconds. It does not automatically handle head-offset-rotations.
            NB: If targetProviderHead/Eyes are both, the behavior will have no effect.
            NB: Requested lookat-offsets for head/eyes will *only* be reset when the behavior resumes/resets.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.LookAtBehavior.#ctor(VirtualBeings.Tech.BehaviorComposition.IActivity,System.Func{UnityEngine.Vector3},System.Single,System.Nullable{VirtualBeings.Tech.BehaviorComposition.ExpressionWrapper},System.Func{UnityEngine.Vector3},System.Single,System.Single,System.Single)">
            <summary>
            LookAt makes character look at target with a specified expression. It also creates small, realistic variations of the expression
            every few seconds. It does not automatically handle head-offset-rotations.
            NB: If targetProviderHead/Eyes are both, the behavior will have no effect.
            NB: Requested lookat-offsets for head/eyes will *only* be reset when the behavior resumes/resets.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.TargetRS">
            <summary>
            Select which stationary RS we target
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.SetTargetRS(VirtualBeings.Tech.BehaviorComposition.IRS,VirtualBeings.Tech.BehaviorComposition.ITransitionType,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request new RS (root state); unless overridden by another request (or this behavior looses control),
            it is guaranteed that this change is eventually successful.
            NB: transition type needs to be set procedurally for now.
            </summary>
            <param name="targetRS"></param>
            <param name="transitionType">Note that this may be overriden if a functional TransitionType is needed
            to leave/arrive at an angle etc.</param>
            <param name="transitionSpeed01"></param>
            <param name="transitionIntensity01"></param>
            <param name="transitionLeftRight"></param>
            <param name="transitionParameterA"></param>
            <param name="transitionParameterB"></param>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.IsInRSChange">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.Goal">
            <summary>
            Goal in world-space
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.TargetInteractable">
            <summary>
            Optional target. If set, Goal is automatically re-routed to its SalientPosition.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.ArrivalDistance">
            <summary>
            How much in front of the goal the agent should stop. If 0, this Behavior will
            try to move the agent-root precisely (on)to the goal.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.MinWalkDistance">
            <summary>
            What is the minimum distance we need to be able to traverse in order to move via steering?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.CanMoveViaStep">
            <summary>
            If distance to goal is too short for steering, can we do a step instead?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.AvoidObstacles">
            <summary>
            If false, goal will be pursued up to ArrivalDistance, no matter if there are obstacles on the way.
            Useful when obstacle avoidance must be switched off in situations of distress.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.TryNiceStopIfPossible">
            <summary>
            Do the transition from a motion RS to a stopped RS using an OT rather than a crossfade.
            Looks better, but is less precise.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.Speed">
            <summary>
            The desired maximum speed. This interpolates between animations.
            Neutral value depends on animation design.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.SpeedMultiplier01">
            <summary>
            The desired speed multiplier. This simply speeds up / slows down locomotion animations.
            Neutral value is .5f.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.OffsetLeftRight">
            <summary>
            Should we move with a left-preferred gait (-1), neutral (0) or right-preferred (1)?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.DoStrafe(System.Single,System.Single)">
            <summary>
            Move sidewards. NB: can only be changed when the actuator is moving or has at least started moving.
            </summary>
            <param name="leftRight">current range is -0.5..0.5, corresponding to 45 degrees left/right</param>
            <param name="urgenyFactor01"></param>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.TargetTimeToFullStop">
            <summary>
            The desired crossfade time when ending locomotion
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.StopUponArrival">
            <summary>
            When arriving from locomotion state, terminate instead of transitioning to Stand.
            Must be set anew each time MoveTo is started (before or after Start())
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.SteerDuringArrival">
            <summary>
            Currently a hack to avoid that the being tries to avoid an interactable that it's running towards
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.IsInDistressHandler">
            <summary>
            Only set to true if this MoveTo is part of a distress handler
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.IsBlocked">
            <summary>
            If true, then pathfinding is unable to find a free path all the way to the goal (minus ArrivalDistance).
            Will remain true if it was true when Behavior terminated
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.RemainingTraversibleDist">
            <summary>
            The distance remaining, minus ArrivalDistance.
            NB: will initially be set to float.MaxValue for an undefined period of time
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.GetLengthOfStraightCorridor(UnityEngine.Vector3)">
            <summary>
            Encapsulates _navClient.GetLengthOfStraightCorridor()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.IsDirectlyAccessible(UnityEngine.Vector3,System.Boolean)">
            <summary>
            Can target be reached along a straight corridor?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.GetRemainingTraversibleDist(UnityEngine.Vector3)">
            <summary>
            Service method that's usable whether or not this behavior is Active.
            How far could we go (not necessarily on a straight line) if we tried ot reach goal via pathfinding?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.WillBeCrossingIntersector(VirtualBeings.Tech.UnityIntegration.IPathIntersector)">
            <summary>
            Check whether the provided intersector will be crossing the planned path, from our current position
            to the target.
            If the MoveTo is not active, this will always return false, as the path in cache would not make any sense.
            </summary>
            <param name="intersector"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.#ctor(VirtualBeings.Tech.BehaviorComposition.ServiceActivity,System.Func{UnityEngine.Vector3},System.Single,System.Single,System.Single,System.Single)">
             <summary>
            
             </summary>
             <param name="parentServiceActivity"></param>
             <param name="goal"></param>
             <param name="speed">Used by animation BlendTree (usually -1 : backward, 0 : inplace, 1 : forward)</param>
             <param name="speedMultiplier01"></param>
             <param name="arrivalDistance"></param>
             <param name="targetTimeToFullStop"></param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.Start(VirtualBeings.Tech.BehaviorComposition.BodyResetType,System.Single,System.Single,System.Func{UnityEngine.Vector3},System.Int32)">
            <summary>
            Configurable starter
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.DoStandIfNecessary(System.Single,System.Single)">
            <summary>
            Determine if we need to request Stand, and do so if yes
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.MoveToBehavior.DoSteering(System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Steering now works because it affects the root Y angle directly; also no more retromapping
            to turntightness (which created oscillations I could never eliminate; in the future this can be replaced by the FFBIK)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.TargetRS">
            <summary>
            Select which stationary RS we target
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.StayBehavior.SetTargetRS(VirtualBeings.Tech.BehaviorComposition.IRS,VirtualBeings.Tech.BehaviorComposition.ITransitionType,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request new RS (root state); unless overriden by another request, the Actuator guarantees that this change
            is eventually successful.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.TimeToStop">
            <summary>
            If Stay has to call Actuator.Root.DoStand, this will be the transition time
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.IsInRSChange">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.IsInST">
            <summary>
            NB: Stay is *not* persistent when it comes to ST's. This property returns true as soon as a ST
            has been requested, but this does not mean that the request will succeed.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.MostRecentST">
            <summary>
            What was the most recently *requested* ST for this behavior?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.StayBehavior.IsInTransition">
            <summary>
            TODO
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.StayBehavior.GetLengthOfStraightCorridor(System.Single,System.Single,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.StayBehavior.GetRemainingTraversibleDist(UnityEngine.Vector3)">
            <summary>
            Service method that's usable whether or not this behavior is Active.
            How far could we go (not necessarily on a straight line) if we tried ot reach goal via pathfinding?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.StayBehavior.RequestST(VirtualBeings.Tech.BehaviorComposition.IST,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request transition to ST (self transition). Note that unlike RS, ST are (1) not guarranteed and
            (2) interruptible by another ST request or a RS change request
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.StayBehavior.ReconfigureST(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Allows changing parameters for long/looped STs
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.BehaviorComposition.StayBehavior.DefaultTransitionUrgencyFactor01">
            Internal logic
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.TailAdditiveBehavior.TransitionToBaseConfiguration(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Configure tail pose (height and curving)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.TailAdditiveBehavior.DoAdditiveTailExpression(VirtualBeings.Tech.BehaviorComposition.IAdditiveTailExpression,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Move the tail in an expressive way
            </summary>
            <param name="additiveTailExpression">The type of the expression</param>
            <param name="intensity01">E.g. how high the tail goes in a tail flap</param>
            <param name="duration01">How enduring the expression is (not the same as speed; this may actually select different animations)</param>
            <param name="speed01">Global speed multiplier</param>
            <param name="angleInDegs">How far left (negative) or right (positive) the tail should lean during the expression</param>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.BehaviorT`1">
            <summary>
            This class just serves to make a typed Start() method available to all behaviors
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Interval">
            <summary>
            Struct that defines a float interval [min, max]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Interval.Evaluate(System.Single)">
            <summary>
            Given a normalized float (0; 1), evaluate this interval
            </summary>
            <param name="normalized"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Interval.Evaluate01(System.Single,System.Boolean)">
            <summary>
            Given a value between min and max, return a normalized (0 ; 1) value.
            </summary>
            <param name="value"></param>
            <param name="clampMaxValue"></param>
            <returns></returns>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ITerminatable.TerminatableThisFrame">
            <summary>
            Can the worker be interrupted this frame?
            NB: this is just a *hint* for parents that they can ignore. All workers are always interruptible.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.ITerminatable.TerminationRequested">
            <summary>
            NB: If implemented in a class derived from Process, then this is automatically reset at Start
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Activity">
            <summary>
            Base class for all Activities. Use this to create new kinds of Activities, which will
            require implementing MainProcess(), Enter() and Exit(). In MainProcess() you can start
            Behaviors, which will automatically wire themselves up to get called each frame.
            You can also instantiate nested Activities which will be executed in parallel with
            your Activity. Correct call order is taken care of.
            
            At any time there can only be a single 'root' Activity per Being. So if you need to run Activities
            in parallel, you must do so inside an Activity. The root Activity has to be ticked
            externally (via IEnumerator returned from public Start()). It must be ticked before
            Actuator.Update().
            
            NB: *don't* create new Activities or Behaviors inside the constructor of an Activity, but only
            in MainActivity() [reason: Activities and Behaviors are recyclable, but their child Activities and Behaviors
            get detached from the calling framework when Finish is called. New Activities and Behaviors must therefore
            be called inside the Start() - Finish() cycle]
            
            Guarantees:
            - Start() is deterministic in both forms, i.e. it cant fail.
            - Interrupt() ensures that the MainProcess won't be called anymore, and that
              the Activity will process Exit() and that of its children and terminate its Behaviors as soon as it is ticked.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Activity.GetExpression">
            <summary>
            Each activity is associated with an expression
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Activity.AddAgentEventListener``1(VirtualBeings.Tech.Utils.EventManager.EventDelegate{``0})">
            <summary>
            Use this to subscribe to an agent event (unsubscription is done automatically)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Activity.RemoveAgentEventListener``1(VirtualBeings.Tech.Utils.EventManager.EventDelegate{``0})">
            <summary>
            Optional. (Event unsubscription is done automatically when Activity exits)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Activity.AddWorldEventListener``1(VirtualBeings.Tech.Utils.EventManager.EventDelegate{``0})">
            <summary>
            Use this to subscribe to a world event (unsubscription is done automatically)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Activity.RemoveWorldEventListener``1(VirtualBeings.Tech.Utils.EventManager.EventDelegate{``0})">
            <summary>
            Optional. (Event unsubscription is done automatically when Activity exits)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Activity.Parent">
            <summary>
            Accessible by descendants
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Behavior">
            <summary>
            Behaviors are essentially domain-specific orchestrations of actuations, and they control the latter on
            a frame-to-frame basis. They are meant to be used *only* inside of Activities.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Behavior.DomainHandler">
            NB: DomainHandler is only instantiated inside arrays, so the fact that it is a struct does not cause boxing.
            See https://stackoverflow.com/questions/14038264/testing-foreach-box-unbox-on-a-regular-array
            and https://stackoverflow.com/questions/8213887/does-system-array-perform-boxing-on-value-types-or-not
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.IsHandlingDomain(VirtualBeings.Tech.BehaviorComposition.Domain)">
            <summary>
            Check if this behavior signed up for a given domain
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.BehaviorComposition.Behavior.Active">
            <summary>
            Is this behavior currently active
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.ActiveAndController">
            <summary>
            Check if behavior is active and controls all domains it has signed up for
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.ActiveAndController(VirtualBeings.Tech.BehaviorComposition.Domain)">
            <summary>
            Check if behavior is active and controls a given domain
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.GetExpression">
            <summary>
            Return the expression currently associated with this behavior
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.SetExpression(VirtualBeings.Tech.BehaviorComposition.IFS,VirtualBeings.Tech.BehaviorComposition.IFTT,System.Single,System.Single)">
            <summary>
            Set the expression currently associated with this behavior
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.Enter">
            <summary>
            Enter is called from Start(), which means that it is called as soon as the user starts the Behavior
            inside the owning Activity. It is NOT called again when a suspended behavior resumes.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.PreTick(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            PreTick is called once per frame, before any available Tickers
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.BehaviorComposition.Behavior.ActuationTicker">
             <summary>
             Methods of type ActuationTicker are called each frame during the PostUpdate() cycle of the top-level Activity. They are
             called according to the Behavior's place in the Behavior graph (i.e. before behaviors created by child
             activities of its owning Activity, and before behaviors that were Start()-ed after it in the same Activity).
            
             ActuationTickers must be registered via entries to the DomainHandlers field of Behavior. See Move.cs for an
             example. Note that ActuationTickers can register for a single domain or for multiple domains. In the latter case,
             they will *only* be called (or reset) if they are currently controllers of *all* the domains they registered for.
             Conversely, an ActuationTicker does *not* get blocked just because a different ActuationTicker in the same Behavior is blocked.
            
             By allowing Behaviors to take over multiple domains with a single ActuationTicker, the behavior composition framework provides a
             flexible solution for *selectively* creating Behaviors that tightly coordinate actuations across multiple
             domains (e.g., via animations in a specialized, multi-domain animation layer). This is useful when timing is really
             important and better done in an animation. In this case, instead of having to make sure that actuations across several
             domains match up precisely, the animation guarantees this kind of precision.
             </summary>
             <param name="resetActuations">When a Behavior has to end then ActuationTickers (of the domains it currently controls)
             will be called one last time with resetActuations==true</param>
             <param name="expressionTypeChanged"></param>
             <param name="expressionIntensityChanged"></param>
             <param name="isStartingOrResuming">Indicates for the duration of one frame if the behavior is starting or if execution on
             the controlled domains is resuming</param>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.Exit">
            <summary>
            Exit is guaranteed to be called whether the Behavior is terminating via internal or external call.
            It is called directly *after* the final call to ExecuteActuation
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.ShouldTerminate">
            <summary>
            Behaviors can override this method to make a per-frame check if they should be interrupted
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.CanRun">
            <summary>
            Behaviors can override this method to make an initial check if any preconditions for running the behavior are fulfilled
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.ResumeInternal(VirtualBeings.Tech.BehaviorComposition.Domain)">
            <summary>
            Resume previously suspended behavior, should only be called by Actuator!
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.BehaviorComposition.Behavior.TakeOverAllTargetDomains">
            <summary>
            Called by Start() to take control over all actuation domains
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BePerched.CanContinueToBeFingerPerched">
            <summary>
            Is the being perched on a finger and can it continue to stay perched ?
            </summary>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.FlyToSafety.TargetType">
            <summary>
            What kind of landing spot should we flee to?
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.StabilizeHead">
             <summary>
            
             Service activity that makes per-frame calls to stay.SetBodyPoseOffsetTargets() of a stay
             behavior from a parent activity.
            
             The goal is to use IK to 'lock' the head in world space when the being is moved (e.g. when perching).
            
             Resets head stabilization automatically after a while, and also when the root of the being moves too far.
            
             </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead._stay">
            <summary>
            Stay behavior provided by the parent
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead._dampedUrgencyFactor01">
            <summary>
            Stateful UF that we can damp upwards at each new stabilization episode
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.InitialDampedUrgencyFactor01">
            <summary>
            Start value for _dampedUrgencyFactor01 (also when reset)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.MaxHeadDelta">
            <summary>
            How far we attempt to move the head to its world target position
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.DampTimeCatchUp">
            <summary>
            How quickly is catchUpUrgency01 lerped towards normalizedCurrentToTargetDist?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.DampTimeUrgencyFactor">
            <summary>
            How quickly is _dampedUrgencyFactor01 lerped towards 1?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.MaxCatchUpSpeed">
            <summary>
            Absolute max speed with which offset head tries to catch up on animated position
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.StabilizeHead.CutOffPoint">
            <summary>
            Above what value of catchUpUrgency01 do we start to catch up on animated head position?
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BirdActivity`1">
            <summary>
            This class provides simple functionality to all bird activities; it's not used for
            polymorphism (thats the role of IBirdActivity).
            NB: The main point of having a superclass for all bird activities is to give convenient access
            to BirdBeing, bird settings and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdActivity`1.VirtualBeings#Tech#Beings#Bird#IBirdActivity#Start">
            <summary>
            Allow bird activities to be started when cast to IBirdActivity
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdActivity`1.UseCog``1">
            <summary>
            NB: this method is here rather than in Mind so it can more easily access 'this' when calling cog.Use(this)
            NB: do not use this method from the constructor of activities, but only from
            either Enter or MainProcess (reason: the cog gets unregistered automatically in Exit)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BirdRootActivity`1">
            <summary>
            This class provides functionality to all bird *root* activities.
            NB: Why is there a BirdRootActivity instead of a RootActivity superclass?
            Because we need to inherit from BirdActivity (see comment there).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdRootActivity`1.VirtualBeings#Tech#BehaviorComposition#IRootActivity#Start">
            <summary>
            Allow bird activities to be started when cast to IBirdActivity
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdRootActivity`1.ReturnMinSatisfierPriorityWhileActive">
            <summary>
            If RA is active, this virtual method can be overridden to force CalculatePriority to return min priority for satisfiers.
            
            Can be overridden by methods such as BeSafe, who need to be essentially uninterruptible by other Satisfiers.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdRootActivity`1.CalculatePriorityFromMotive(System.Single)">
            Private stuff
            <summary>
            For Satisfier-RAs, this is the default function to calculate their priority
            based on whether the RA is active and how (un)satisfied its target motive is.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BirdSelf">
            <summary>
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BirdSelf.Motives">
            public interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdSelf.IsEnticing(VirtualBeings.Tech.UnityIntegration.IInteractable,VirtualBeings.Tech.ActiveCognition.Motive)">
            <summary>
            Crucial method to help make beings more responsive to initiatives from player.
            </summary>
            <param name="interactable">Must not be null or destroyed</param>
            <param name="motive"></param>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdSelf.#ctor(VirtualBeings.Tech.Beings.Bird.BirdMind)">
            infrastructure
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.BirdSelf.Mind">
            protected stuff
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdSelf.IsInSatisfyingMode(VirtualBeings.Tech.ActiveCognition.Motive)">
            private stuff
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.ObstacleDetector">
            <summary>
            Manage all the collider that enter or exit the range of a given trigger collider (a sphere for example), and stores these colliders.<br/>
            Used to detected all obstacles near the being.<br/>
            / ! \ - This collider must have a rigid body, and have the collider "is trigger" set to true.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.ObstacleDetector.GetClosestPositionOnColliders(UnityEngine.Vector3)">
            <summary>
            Returns all colliders in range and their closest position to the being
            </summary>
            <param name="beingPosition"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.ObstacleDetector.GetAverageObstaclesDirection(UnityEngine.Vector3)">
            <summary>
            Get the average direction of all near obstacles (from collider to being). <br/>
            The more close an obstacle is, the more influence it has over the final direction.<br/>
            The more magnitude the result has, the more obstacles near the bird there is.
            </summary>
            <param name="beingPosition"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.AdditiveBirdExpressionBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveBirdExpression as an ExtensibleEnum by clients of the KuteEngine server.
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.AdditiveBirdExpressionBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveExpression#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.AdditiveBirdExpressionBase.None">
            Public interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.AdditiveBirdExpressionBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.AdditiveTailExpressionBirdBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of AdditiveTailExpressionBird as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.AdditiveTailExpressionBirdBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveTailExpression#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.AdditiveTailExpressionBirdBase.Hash">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.AdditiveTailExpressionBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.AdditiveTailExpressionBirdBase.#ctor(System.String,System.Int32)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BodyAttitudeBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of RSBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BodyAttitudeBirdBase.Wideness">
            <summary>
            Returns 0 == curled in or drawn in, 1 == neutral, 2 == stretched out, 3 == very stretched out
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BodyAttitudeBirdBase.Hash">
            <summary>
            Hash of this attitude in the animator controller asset
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BodyPoseBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of BodyPoseBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BodyPoseBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BodyPoseBirdBase.#ctor(System.String)">
            Internals
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BirdBeing.BirdMind">
            internal properties
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.BirdBeing.AgentType">
            implementations of abstract members
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.BirdBeing.SetRelationship(VirtualBeings.Tech.BehaviorComposition.Being,System.Boolean)">
            'workhorse' members and methods to get the *infrastructure* of the Being going
        </member>
        <member name="F:VirtualBeings.Tech.Beings.Bird.BirdBeing._root">
            other private fields
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.BirdSharedServerSettings.BirdBehaviorSettings">
            Behaviors
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.FSBirdBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of FSBird as an ExtensibleEnum by clients of the KuteEngine server.
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FSBirdBase.Vivacity">
            Public non-static interface
            <summary>
            Has range 0..1, where .5 means 'neutral' vivacity
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FSBirdBase.EyesClosed">
            <summary>
            Marks states like 'Sleeping' or 'SatisfiedEyesClosed' which have eyes completely closed at intensity=1
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FSBirdBase.IsBasic">
            <summary>
            True if this is one of the seven 'basic', hardcoded expressions, as per J.Turner (see IFSEnums).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FSBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.FSBirdBase.#ctor(System.String,System.Single,System.Boolean)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.FSTBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FSTBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.FSTBirdBase.VirtualBeings#Tech#BehaviorComposition#IFST#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FSTBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.FSTBirdBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.FTTBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FTTBird (Facial transition type / Birds) as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.FTTBirdBase.VirtualBeings#Tech#BehaviorComposition#IFTT#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.FTTBirdBase.Default">
            Public static interface
            <summary>
            Note: for facial state transitions (facial 'OTs'), 'Default' is always a direct crossfade
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.FTTBirdBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.RSBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of RSBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.RSBirdBase.Side">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.RSBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.RSBirdBase.#ctor(System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,VirtualBeings.Tech.BehaviorComposition.StateUpness)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.STBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of STBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.STBirdBase.IsSTC">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.STBirdBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.STBirdBase.#ctor(System.Boolean,System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Bird.TransitionTypeBirdBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of TransitionTypeBird as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.TransitionTypeBirdBase.VirtualBeings#Tech#BehaviorComposition#ITransitionType#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Bird.TransitionTypeBirdBase.Default">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Bird.TransitionTypeBirdBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.AdditiveEarExpressionFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveEarExpressionFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.AdditiveEarStateFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveEarStateFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.AdditiveFloaterExpressionBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveFloaterExpression as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.BodyPoseFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of BodyPoseFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.BodyAttitudeFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of BodyAttitudeFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Floater.BodyAttitudeFloaterBase.Wideness">
            <summary>
            Returns 0 == curled in or drawn in, 1 == neutral, 2 == stretched out, 3 == very stretched out
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Floater.BodyAttitudeFloaterBase.Hash">
            <summary>
            Hash of this attitude in the animator controller asset
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.FloaterMotiveType">
            <summary>
            Panksepp-inspired set of motives.
            See Montag/Panksepp: Primary Emotional Systems and Personality, An Evolutionary Perspective (2017)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Floater.FloaterRootActivity`1.VirtualBeings#Tech#BehaviorComposition#IRootActivity#Start">
            <summary>
            Allow floater activities to be started when cast to IFloaterActivity
            </summary>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Floater.FloaterRootActivity`1.ReturnMinSatisfierPriorityWhileActive">
             <summary>
             If RA is active, this virtual method can be overridden to force CalculatePriority
             to return min priority for satisfiers.
            
             Can be overridden by methods such as BeSafe, who need to be essentially uninterruptible by other Satisfiers.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Floater.FloaterRootActivity`1.CalculatePriorityFromMotive(System.Single)">
            <summary>
            For Satisfier-RAs, this is the default function to calculate their priority
            based on whether the RA is active and how (un)satisfied its target motive is.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.FSFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FSFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.FSTFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FSTFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Floater.FTTFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FTTFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.AdditiveHumanoidExpressionBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveFloaterExpression as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.BodyAttitudeHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of BodyAttitudeHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Humanoid.BodyAttitudeHumanoidBase.Wideness">
            <summary>
            Returns 0 == curled in or drawn in, 1 == neutral, 2 == stretched out, 3 == very stretched out
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.Humanoid.BodyAttitudeHumanoidBase.Hash">
            <summary>
            Hash of this attitude in the animator controller asset
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.BodyPoseHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of BodyPoseHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidFBIK.DoGrounding(System.Int32)">
             <summary>
             Ground one foot, 0 is left foot, 1 is right foot.
            
             NOTE(Charly): There are limitations in the current grounding, which are mostly documented as TODO in different
             parts of the code.
             A quick discussion about the limitations can also be found here:
             https://discord.com/channels/459638929507876864/1070275401500336148/1083860606416859259
            
             Quick wrap up here:
             Charly: So, I changed a bit the grounding computations, the "dampening" / "smoothing" of the foot to not follow the terrain was causing issues during the "catch up with the ground" phase.
             Given the profile of the terrain (very low frequency) I think this works well, and it has the added benefit of never penetrating the terrain.
             My main issue currently is that I rely on the animation to give me the expected distance to the ground, which means that, during turns, it could behave weirdly. But given the way the animations are made (the toes are not at a constant distance from the ground during the "lifting" of the foot, when attached), I cannot really rely on a setting or something to determine that distance when attached
             I hope this will be enough for the demo
             But this is definitively not definitive
             Wendi:
             What would be different during a turn that could make it behave weirdly? Is this something you have already seen?
             Charly:
             I have not seen it, but we rely on the blending between the animations
             (And by extension the retargeting Unity does, if we have different avatars)
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidFBIK.GetCorrectiveOffsetForLimb(System.Single,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            <summary>
            Do foot-sliding prevention for a single limb. This changes only XZ coordinates, never Y.
            NB: unlike InterpolateLimbTargetOffset, which also uses detachment values (Detach_XX), here we
            just try to catch up with the animation when we're detached, so we're not really 'stateful' and everything is simpler.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidFBIK.UpdateGroundingDeltaYForFoot(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@)">
            <summary>
            Compute the delta on Y axis to apply to properly ground the character.
            TODO: Right now, this just enforces the ground to be followed. This is visually ok on low frequency terrains.
            This will need to change to be able to smooth the terrains.
            NOTE(Charly): I made this simplification because I could not find a correct way to both dampen the
            foot catching up with the ground while not having some kind of "bounciness" or feet elevation when the root
            was too far away from the ground.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidFBIK.UpdateLookAt">
             <summary>
             We are using the Unity IK system, and it is purely stateless, we give it a look target, and it solves the IK
             for that. That means that we need to handle the fact that the look target does not have to be provided
             by an at least C0 function and smooth it ourself.
             The smoothing is done through simple arrival steering, nothing very fancy
             (see https://natureofcode.com/book/chapter-6-autonomous-agents/ chapter 6.4 for example).
            
             Revamp:
             Project the requested target on a sphere centered at the the current look target on a sphere
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidFBIK.ToCartesian(System.Single,System.Single)">
            <summary>
            Assumes a radius of 1 (unit sphere) centered on 0
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.FSHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FSHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.FSTHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FSTHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.FTTHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FTTHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.HumanoidMotiveType">
            <summary>
            Panksepp-inspired set of motives.
            See Montag/Panksepp: Primary Emotional Systems and Personality, An Evolutionary Perspective (2017)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidRootActivity`1.VirtualBeings#Tech#BehaviorComposition#IRootActivity#Start">
            <summary>
            Allow floater activities to be started when cast to IHumanoidActivity
            </summary>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidRootActivity`1.ReturnMinSatisfierPriorityWhileActive">
             <summary>
             If RA is active, this virtual method can be overridden to force CalculatePriority
             to return min priority for satisfiers.
            
             Can be overridden by methods such as BeSafe, who need to be essentially uninterruptible by other Satisfiers.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.Humanoid.HumanoidRootActivity`1.CalculatePriorityFromMotive(System.Single)">
            <summary>
            For Satisfier-RAs, this is the default function to calculate their priority
            based on whether the RA is active and how (un)satisfied its target motive is.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.RSHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of RSHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.STHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of STHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.Humanoid.TransitionTypeHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of TransitionTypeHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarExpressionSmallQuadrupedBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of AdditiveEarExpressionCat as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarExpressionSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveEarExpression#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarExpressionSmallQuadrupedBase.Hash">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarExpressionSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarExpressionSmallQuadrupedBase.#ctor(System.String,System.Int32)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarStateSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of AdditiveEarStateCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarStateSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveEarState#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarStateSmallQuadrupedBase.OffsetX">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarStateSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveEarStateSmallQuadrupedBase.#ctor(System.String,System.Single,System.Single,System.Single,System.Single)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveTailExpressionSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of AdditiveTailExpressionCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveTailExpressionSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveTailExpression#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveTailExpressionSmallQuadrupedBase.Hash">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveTailExpressionSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveTailExpressionSmallQuadrupedBase.#ctor(System.String,System.Int32)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyAttitudeSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of RSCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyAttitudeSmallQuadrupedBase.Wideness">
            Public non-static interface
            <summary>
            Returns 0 == curled in or drawn in, 1 == neutral, 2 == stretched out, 3 == very stretched out
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyAttitudeSmallQuadrupedBase.Hash">
            <summary>
            Hash of this attitude in the animator controller asset
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyAttitudeSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyAttitudeSmallQuadrupedBase.#ctor(System.String,System.Int32,System.Int32)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyPoseSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of BodyPoseCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyPoseSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.BodyPoseSmallQuadrupedBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of FSCat as an ExtensibleEnum by clients of the KuteEngine server.
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase.Vivacity">
            Public non-static interface
            <summary>
            Has range 0..1, where .5 means 'neutral' vivacity
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase.EyesClosed">
            <summary>
            Marks states like 'Sleeping' or 'SatisfiedEyesClosed' which have eyes completely closed at intensity=1
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase.IsBasic">
            <summary>
            True if this is one of the seven 'basic', hardcoded expressions, as per J.Turner (see IFSEnums).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSSmallQuadrupedBase.#ctor(System.String,System.Single,System.Boolean)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSTSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of FSTCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSTSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#IFST#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSTSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.FSTSmallQuadrupedBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.FTTSmallQuadrupedBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of FTTCat (Facial transition type / Cats) as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.FTTSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#IFTT#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.FTTSmallQuadrupedBase.Default">
            Public static interface
            <summary>
            Note: for facial state transitions (facial 'OTs'), 'Default' is always a direct crossfade
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.FTTSmallQuadrupedBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.TransitionTypeSmallQuadrupedBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of TransitionTypeCat as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.TransitionTypeSmallQuadrupedBase.VirtualBeings#Tech#BehaviorComposition#ITransitionType#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.TransitionTypeSmallQuadrupedBase.Default">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.TransitionTypeSmallQuadrupedBase.#ctor(System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.RSSmallQuadrupedBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of RSCat as an ExtensibleEnum by clients of the KuteEngine server
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.RSSmallQuadrupedBase.Side">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.RSSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.RSSmallQuadrupedBase.#ctor(System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,VirtualBeings.Tech.BehaviorComposition.StateUpness)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.STSmallQuadrupedBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of STCat as an ExtensibleEnum by clients of the KuteEngine server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
             to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.STSmallQuadrupedBase.IsSTC">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.STSmallQuadrupedBase.None">
            Public static interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.STSmallQuadrupedBase.#ctor(System.Boolean,System.String)">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveSmallQuadrupedExpressionBase">
            <summary>
            Marker ABC known by KuteEngine to ensure type-safe use of AdditiveCatExpression as an ExtensibleEnum by clients of the KuteEngine server.
            
            PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class. This means that it's not possible
            to further generalize it into a superclass that works for cats, birds and so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveSmallQuadrupedExpressionBase.VirtualBeings#Tech#BehaviorComposition#IAdditiveExpression#FromID_viaInstance(System.Int32)">
            Public non-static interface
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveSmallQuadrupedExpressionBase.None">
            Public interface
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.AdditiveSmallQuadrupedExpressionBase.#ctor(System.String)">
            Internals
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.SmallQuadrupedBeing.SmallQuadrupedMind">
            internal properties
        </member>
        <member name="P:VirtualBeings.Tech.Beings.SmallQuadrupeds.SmallQuadrupedBeing.BeingSettings">
            implementations of abstract members
        </member>
        <member name="M:VirtualBeings.Tech.Beings.SmallQuadrupeds.SmallQuadrupedBeing.SetRelationship(VirtualBeings.Tech.BehaviorComposition.Being,System.Boolean)">
            'workhorse' members and methods to get the *infrastructure* of the Being going
        </member>
        <member name="T:VirtualBeings.Tech.Network.NetworkInterface">
             <summary>
             This interface is the entry point for all network related calls from and to the Beings.
             It is agnostic of any network solution, and the synchronization of the data sent through the interface has
             to be implemented by the user.
            
             Each function can be seen as a host / client duet, with the host calling the "Send" or "Update" function, that then
             gets sent over the network, and the counterpart "OnReceived" or "OnUpdated" then gets called by the client upon
            
             For most of the calls, SendData() is called by the host (and must be forwarded to the clients via OnDataReceived()).
             It can be thought of (and should probably be treated as) an RPC call.
            
             Some properties need a per frame synchronization (root transform or look targets for example), and are hence
             separated to allow special treatment / optimizations (e.g. only sending if they change).
            
             Upon initialization of a client being, retrieve the current state of the host by querying it through
             GetBeingState(), and forward the result to the client using SetBeingState().
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.SendData(System.Byte[])">
            <summary>
            Called by the host. The given (opaque) buffer has to be transmitted to all the clients.
            Sending this buffer is the responsibility of the user, using the network solution of its choice.
            This call can be thought of (and should probably be implemented as) an RPC call.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.OnDataReceived(System.Byte[])">
            <summary>
            When the client receives a message coming from the host (via a call to SendData()),
            it has to be forwarded to KuteEngine using this method.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.UpdateLookData(System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Vector3})">
            <summary>
            Called by the host on a per frame basis. Send data is then forwarded to the client using OnLookDataUpdated.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.UpdateRootTransform(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Called by the host on a per frame basis. Sent data is then forwarded to the client using OnRootTranformUpdated.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.GetBeingState">
             <summary>
             Should be called by the host after the connection of a new client.
             The result is then sent to the client, and it has to call SetBeingState with the given buffer.
             This can also be used to recover the state of the host after losing too much information and the beings
             get desynchronized from the host state.
            
             Warning: This buffer is quite big compared to the one in SendData (a bit less that 3kB), so it might require
             special treatment given the limitations of the networking solution.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.SetBeingState(System.Byte[])">
            <summary>
            Called by the client upon reception of the result of GetBeingState sent by the host.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.GetNetworkInteractableId(System.Int32)">
             <summary>
             Called by the host each time it has to send a call that involves an interactable (that should be networked and
             managed by the user). It is used to make the link between the local (managed by KuteEngine) IInteractable.ID,
             associated after the IInteractable got initialized on KuteEngine's side.
            
             NOTE: The returned value MUST be strictly greater that 0.
            
             NOTE: No caching is done on KuteEngine's side, the function gets called every time the information is needed
             for an interactable.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Network.NetworkInterface.GetLocalInteractableId(System.Int32)">
             <summary>
             Called by the client after a call involving an interactable has been received. This allows the client being
             to retrieve the correct local interactable.
            
             See GetNetworkInteractableId.
            
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Network.NetworkSerializer.RootPosition">
            <summary>
            This is supposed to be used only if you are not authoritative over the state of the being.
            To update the state over the network, use UpdateRootTransform.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ITickable">
            <summary>
            Interface for executing instructions (on Tick()) that are called on a per-frame basis (as in MonoBehaviour.Update())
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IFixedTickable">
            <summary>
            Interface for executing instructions (on FixedTick()) that are called on a per-frame basis (as in MonoBehaviour.FixedUpdate())
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Container">
            <summary>
            Contains the entire context of KuteEngine.<br/>
            Access this to access KuteEngine's components.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Container.RegisterTickable(VirtualBeings.Tech.UnityIntegration.ITickable)">
            <summary>
            Register a tickable in the current context that will have its <see cref="M:VirtualBeings.Tech.UnityIntegration.ITickable.Tick"/> called each frame.
            </summary>
            <param name="tickable"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Container.UnregisterTickable(VirtualBeings.Tech.UnityIntegration.ITickable)">
            <summary>
            Unregister a tickable in the current context.
            </summary>
            <param name="tickable"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Container.RegisterFixedTickable(VirtualBeings.Tech.UnityIntegration.IFixedTickable)">
            <summary>
            Register a fixed tickable in the current context that will have its <see cref="M:VirtualBeings.Tech.UnityIntegration.IFixedTickable.FixedTick"/> called each fixed frame.
            </summary>
            <param name="fixedTickable"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Container.UnregisterFixedTickable(VirtualBeings.Tech.UnityIntegration.IFixedTickable)">
            <summary>
            Unregister a fixed tickable in the current context.
            </summary>
            <param name="fixedTickable"></param>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Chunk">
            <summary>
            A chunk represent a list of node disposed inside a box shape. The box is the chunk.
            A chunk meets the following requirements :
            - Box shape
            - All the nodes inside are free to move (no static obstacle)
            - To move from a node to another inside the same chunk, we can do it in a "straight line"
            
            A chunk help us to optimize the calculation of a path between two nodes.
            
            A chunk knows its other neighbour chunk, and what nodes of his is neighbouring the other chunk's nodes.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Chunk.worldBounds">
            <summary>
            Contains the bounds if this chunks in world position
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Chunk.minCoordinate">
            <summary>
            Coordinate of the min node of this node, inside the world node matrix
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Chunk.maxCoordinate">
            <summary>
            Coordinate of the max node of this node, inside the world node matrix
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Chunk.AddNode(VirtualBeings.Tech.UnityIntegration.Node)">
            <summary>
            Add a node for this chunk. Calculate the new min / max / size of this chunk.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.ChunkWindow.direction">
            <summary>
            Simple 1 dimension direction that go from the first chunk to the second chunk
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.ChunkWindow.nodes">
            <summary>
            Key : the node of the current chunk
            Values : the nodes where the key node can travel to (3x3 max), that are inside the other chunk
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkWindow.#ctor(VirtualBeings.Tech.UnityIntegration.Node,VirtualBeings.Tech.UnityIntegration.Node,UnityEngine.Vector3)">
            <summary>
            direction go from the first chunk to the second chunk
            </summary>
            <param name="firstNode"></param>
            <param name="secondNode"></param>
            <param name="direction"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkWindow.RecalculateWeight">
            <summary>
            The weight of a Windows is the average weight of all of its nodes.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkWindow.RecalculateBounds(VirtualBeings.Tech.UnityIntegration.Node)">
            <summary>
            Given the new nodes, recalculate the bounds of the windows
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkWindow.GetFaceInsideChunk(System.Single)">
            <summary>
            Return the bounds (width 0) corresponding to the face of the windows inside the given chunk. (A windows always has 2 face, 1 in each chunk)
            </summary>
            <param name="chunkIdTarget"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding">
            <summary>
            Handle the computation of a path between chunks, given a FlightMap, used for moving though <see cref="T:VirtualBeings.Tech.UnityIntegration.Chunk"/> in 3D space.<br/>
            When the computation is done, the path (<see cref="T:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder"/>) is stored in <see cref="P:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.currentPath"/>.<br/>
            TO use the currentPath, convert it to a <see cref="T:VirtualBeings.Tech.UnityIntegration.ChunkPathFollow"/> with the method <see cref="M:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.ToChunkPathFollow"/>.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.WEIGHT_STATIC_OBSTACLE">
            <summary>
            TODO Raph
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.CreateOpenPath(System.Int32,System.Single,System.Single,System.Single,System.Single,VirtualBeings.Tech.UnityIntegration.ChunkWindow,VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder)">
            <summary>
            Create a new ChunkPath for the given chunkId that should not be open yet, and add it to the open ChunkPath list.
            </summary>
            <param name="chunkID"></param>
            <param name="G"></param>
            <param name="H"></param>
            <param name="W"></param>
            <param name="F"></param>
            <param name="traversedWindow"></param>
            <param name="parent"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.UpdateLinkedNode(VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder,System.Single,System.Single,System.Single,System.Single,VirtualBeings.Tech.UnityIntegration.ChunkWindow,VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder)">
            <summary>
            Update an already existing and opened ChunkPath with new value and new parent
            </summary>
            <param name="chunkPathToUpdate"></param>
            <param name="newG"></param>
            <param name="newH"></param>
            <param name="newW"></param>
            <param name="newF"></param>
            <param name="traversedWindow"></param>
            <param name="newParent"></param>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.G">
            <summary>
            Distance between the start position and this chunk
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.H">
            <summary>
            Distance between this chunk to the goal position
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.W">
            <summary>
            Weight of the last windows
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.F">
            <summary>
            G + H
            The value of this chunkPath. The less, the better this chunkPath is.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ChunkPathFinding.ChunkPathBuilder.ToPath">
            <summary>
            Convert this chunkPath to a path object.
             /!\ NEED TO BE RE ORDERED FROM START TO END BEFORE CONVERTING TO PATH OBJECT
            </summary>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Node">
            <summary>
            Node that correspond to a point in 3D space, where a beings can use to move (fly, swim, ...).
            Node based on a 3D Graph
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Node.Position">
            <summary>
            World position of the node
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Node.canGrowChunk">
            <summary>
            This node can still be a part of a chunk (max 1 chunk)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Node.chunkId">
            <summary>
            Chunk that contain this node.
            TODO : remove
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Node.coordinate">
            <summary>
            Coordinate of this node inside the world node matrix
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Path">
            <summary>
            TODO : change position to a bounds (corresponding to a window)
            then the bird will want to go to the closest point between him and the bounds windows, or the best point (best weighted node) of the window
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ChunkPathFollow">
            <summary>
            Path defined by chunks, with previous windows, next windows, that is used for path following
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BeingManager">
            <summary>
            Manage all Beings lifecycle in the game
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.BeingManager.totalPlayTimeInThisGameSession">
            <summary>
            Total time (in seconds) that the player in the current session. Time in the splashscreen or time the app is backgrounded does not count.
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.UnityIntegration.BeingManager.OnUpdate">
            <summary>
            Unlike unity MonoBehaviour Update(), OnUpdate gets called at every frame even Time.timescale == 0!
            </summary>
        </member>
        <member name="E:VirtualBeings.Tech.UnityIntegration.BeingManager.OnFixedUpdate">
            <summary>
            Unlike unity MonoBehaviour FixedUpdate(), OnFixedUpdate gets called at every frame even Time.timescale == 0!
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BeingManager.InitializeAndStartBeing(VirtualBeings.Tech.UnityIntegration.BeingManager.BeingInfo)">
            <summary>
            Initialize and start this Being.<br/>
            /!\ Must be called after instantiation /!\<br/>
            <br/>
            </summary>
            <param name="beingInfo"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BeingManager.BeingInfo">
            <summary>
            Class used to store information for the initialization and start of a Being Instance.
            Being can be initialized in 3 different modes (Host, Client, Local = default).<br/>
            Host has authority over the Being, and handle the being's Mind and behaviors. Host being need a <paramref name="networkInterface"/>.<br/>
            Client doesn't have authority over the Being, and replicate what the host do on the Actuator level. Client being need a <paramref name="networkInterface"/>.<br/>
            Local has authority over the Being but does not need to replicate it over a network. Local doesn't need a<paramref name="networkInterface"/>.<br/>
            <br/>
            Optionnaly, override the default execution type given in <paramref name="beingSettings"/>.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BeingManager.OnApplicationQuit(VirtualBeings.Tech.UnityIntegration.Event_Unity_OnApplicationQuit)">
            <summary>
            IMPORTANT: on android OnApplicationQuit IS NOT CALLED when:
            the app is first paused (the user goes to back to home page for example) and then destroyed by the user (removed from current active tasks for example)
            thats why we should also save the player data when the application is paused
            </summary>
            <param name="_"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BeingManager.OnApplicationPause(VirtualBeings.Tech.UnityIntegration.Event_Unity_OnApplicationPause)">
            <summary>
            during all the time the application is paused (android app in background for example), Time.time is not moving forward even if the time scale is not zero.
            so we do not need to set Time.timescale to zero on application pause.
            </summary>
            <param name="_"></param>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BeingManager.SpawnableBeings">
            <summary>
            Define multiple spawnable being that share the same Shared Settings.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BeingManager.BeingInstance">
            <summary>
            Define a unique being instance
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BeingManager.SceneProcess">
            <summary>
            NB: this class is responsible for GameManager.LevelState
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BeingManager.SceneProcess.MainProcess">
            <summary>
            The purpose of this class is to handle scene switching in the following enumerator.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableManager.GetPreference01(VirtualBeings.Tech.BehaviorComposition.Being,System.Int32)">
            <summary>
            TODO :  move this function on a WorldAssetManager ?
            How much between 0 and 1, the being 'likes' the given interactable.
            </summary>
            <param name="being"></param>
            <param name="worldAssetID"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableManager.GetPreference01(VirtualBeings.Tech.BehaviorComposition.Being,VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            How much between 0 and 1, the being 'likes' the given interactable.
            </summary>
            <param name="being"></param>
            <param name="interactable"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableManager.GetTotalCalories(System.Int32)">
            <summary>
            TODO : move this function on a WorldAssetManager ?
            Return the total calories of the interactable corresponding to the given worldAssetID.
            </summary>
            <param name="worldAssetID"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableManager.GetTotalCalories(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Get the calories of the given interactable.
            </summary>
            <param name="interactable"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IObstacle">
            <summary>
            Considered as an obstacle in the KuteEngine's navigation system 
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.NavigableTerrainManager">
            <summary>
            Manage all navigable terrain in the current context.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrainManager.GetClosestNavigableTerrain(UnityEngine.Vector3)">
            <summary>
            TODO
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.SoundManager">
            <summary>
            Handle the sounds played by the beings
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AutoDecay">
            <summary>
            Encapsulates a float value from 0..X that automatically gets smaller based on exponential decay.
            For math see https://www.wolframalpha.com/input?i=plot+%281+-+.1%29%5Ex+for+x%3D0.0+..+30
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.AutoDecay._decayConstant">
            <summary>
            For exponential decay, the decay constant determines the half-life time of the initial value.
            It is calculated as follows: .5^(time-unit/half-life-time-in-units).
            A value of .5 gives 1 second, a value of .9 roughly 6.5 seconds.
            See https://en.wikipedia.org/wiki/Exponential_decay#Half-life
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IVariableDriverInfo">
            <summary>
            Animation-driven float variable
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.PostProcessAnimation.AnimationEventDispatcher(System.String)">
            <summary>
            Method registered in FBX importer, called by Animator
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.PostProcessAnimation.GetVariableDriverInfo(System.String)">
            <summary>
            Provides access to an animated property; slow
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.PostProcessAnimation.UpdateDrivers">
            <summary>
            Called by Actuator to update blend shape drivers, layer drivers and animated properties
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.PlayerAgent">
            <summary>
            Represent a player (that is a IAgent)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.PlayerAgent.HandleCameraFOV(System.Object)">
            <summary>
            Event handler that changes (vertical) FOV
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IPerch">
            <summary>
            This interface implies RootParentType.Perch or RootParentType.Finger
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IPerch.BendAmount">
            <summary>
            Get angle that says how bent the perch is (for a finger, this is the angle between forward axes of first and last finger bone).
            The direction of the bend is not interesting because this is only used to accept/reject perch point or trigger TakeOff
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IRootParentProvider">
            <summary>
            Interactable on which a being can stand, sit or perch etc. Provides all information to allow
            fake parenting by the being (where the being simply moves its root to ConnectionPoint in each LateUpdate).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.RootParentType">
            <summary>
            Type that defines how a being should attach itself to the parent
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ConnectionPosition(VirtualBeings.Tech.BehaviorComposition.Being)">
            <summary>
            Calculate current world position of the connection point (where the root of the being should be)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ConnectionRotation">
            <summary>
            Current world rotation of the connection point (where the root of the being should be)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ConnectionForward">
            <summary>
            Forward axis of the connection point (e.g., for a finger, this points from finger root to tip)
            NB: this is the same as ConnectionRotation * Vector3.forward
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ConnectionUp">
            <summary>
            Up axis of the connection point, necessary to make use of MaxPermissibleAngleFromVector3Up
            NB: this is the same as ConnectionRotation * Vector3.up
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ConnectionRight">
            <summary>
            Right axis of the connection point
            NB: this is the same as ConnectionRotation * Vector3.right
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.MaxPermissibleDistFromConnectionPosition">
            <summary>
            At what distance between ConnectionPosition and Being.RootPosition do we force termination of *inactive* root parenting?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ApproachTarget">
            <summary>
            From/to which point (in global space) should the ConnectionPosition best be approached or left?
            This works together with MaxApproachAngle:
            - if MaxApproachAngle >= 180f, ApproachTarget is unused
            - if MaxApproachAngle == 0f, Being needs to traverse the line segment
              ConnectionPosition-ApproachTarget precisely when using or leaving the root parent provider.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.MaxApproachAngle">
            <summary>
            See ApproachTarget for explanation
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ReadyForRootParenting(VirtualBeings.Tech.BehaviorComposition.Being)">
            <summary>
            Is the parenting point ready to be used by being?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.NotifyUseOfPerchPoint(VirtualBeings.Tech.BehaviorComposition.Being)">
            <summary>
            Tell perch point that being is using it
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IRootParentProvider.ReleaseUseOfPerchPoint(VirtualBeings.Tech.BehaviorComposition.Being)">
            <summary>
            Tell perch point that being has stopped using it
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IWalkableZone">
            <summary>
            A *circular* part of a navigable terrain that's sufficiently flat and unencumbered by static obstacles
            to be walkable by a being. Can however include dynamic obstacles.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IWalkableZone.GetRandomFreePosition(VirtualBeings.Tech.BehaviorComposition.Being,System.Single,UnityEngine.Vector3@,System.Single,System.Int32)">
            <summary>
            Use spherecasting to find a randomized, free (unobstructed) position where being can be (e.g., by landing).
            </summary>
            <param name="being">The being that wants to use this position</param>
            <param name="freeRadius">How much free space we require (at least) at the returned <paramref name="position"/></param>
            <param name="position">The free position</param>
            <param name="maxDistFromCenter">How far from the zone's center the position is allowed to be</param>
            <param name="nMaxAttempts">How many attempts until we give up?</param>
            <returns>False if no free position could be found</returns>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.AgentEvent_Salient.TimeOfLastHandling">
            <summary>
            The last time this event was somehow interacted with (useful and necessary because event objects
            are recycled when their contained Interactable triggers a new event)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AgentEvent_Movement">
            <summary>
            Fired when there is an (interesting) relative movement of an object in the FOV, i.e. the object just appeared
            or it moves in relevant ways.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AgentEvent_Smell">
            <summary>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AgentEvent_DistractionChanged">
            <summary>
            Fired by TrackedEventDB whenever TrackedEventDB.DistractingEvent is set to a new value (including null).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AgentEvent_Touch">
            <summary>
            Fired whenever this being is touched by a player
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.CommunicativeAct">
            <summary>
            TODO in the future, change to ExtensibleEnum
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.RegisterGameObjectAsObstacle(UnityEngine.GameObject,System.Single,System.Single)">
            <summary>
            Call RegisterGameObjectAsObstacle for all navservers
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.UnregisterGameObjectAsObstacle(UnityEngine.GameObject)">
            <summary>
            Call UnregisterGameObjectAsObstacle for all navservers
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.GetNewNavServerAndRegisterBeing(System.Int32,UnityEngine.GameObject[],System.Single,System.Int32@,UnityEngine.LayerMask@)">
            <summary>
            Get a NavServer which contains all other registered beings *except* for the calling being
            </summary>
            <param name="beingID"></param>
            <param name="gosWithCollidersOnBeing">If null, then this being wont be in the navmeshes</param>
            <param name="borderOffset"></param>
            <param name="ownCharacterLayer"></param>
            <param name="otherCharactersLayerMask"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.ReleaseNavServerAndUnregisterBeing(System.Int32,UnityEngine.GameObject[])">
            <summary>
            Release and optionally unregister caller
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.IsInPlayerArea(UnityEngine.Vector3,System.Single)">
            Determine if position is inside player area and
            - if margin is positive: at least 'margin' inside of it (this now works just like 'ClosestPointInsidePlayerArea()');
            - if margin is negative: at most '-margin' away from it
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.DistToPlayerArea(UnityEngine.Vector3)">
            <summary>
            PS: why not give users of INavigableTerrain direct access to BoundsOfPlayerArea? Because they shouldn't assume
            that the player area is an AABB. In the future, this area may have different shapes.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigableTerrain.INavigableTerrain.ClosestPointInsidePlayerArea(UnityEngine.Vector3,System.Single)">
            <summary>
            Get closest point inside player area for 'position', and ensure that this point is
            at least at distance 'margin' *inside* of the border.
            Result undefined if margin is larger than any vector from border to center.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.NamedArrayAttribute">
            <summary>
            See https://answers.unity.com/questions/1626818/change-the-name-of-list-elements-in-the-inspector.html
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AutoFlag">
            <summary>
            Class that encapsulates an auto-consuming, reusable flag that is raised via a predicate generator.
            Raising can only happen when IsRaised is called! If that happens, the flag automatically renews itself.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ManualFlag">
            <summary>
            Simple struct that encapsulates an auto-consuming, reusable flag (or semaphore), to be raised from outside
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Perlin">
             <summary>
             Functions for Perlin noise. The Noise() methods provide 1-2-3D noise, whereas the
             Fbm() methods provide more sophisticated noise featuring several overlayn 'octaves'
             that change at different scales. See Keijiro's sample project for a visual explanation
             using noise textures.
            
             A typical way of using this is e.g. x = Noise(Time.time * scaleFactor), where
             x will be [-1..1] and scaleFactor makes the noise wider or narrower.
             </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Perlin.Noise(System.Single)">
            <summary>
            Comment on keijiro's github: "The value range of the Noise functions is [-1.0, +1.0]."
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Perlin.Fbm(System.Single,System.Int32)">
            <summary>
            Comment on keijiro's github: "AFAIK, the value range of the fBm functions is not well - defined.It might be somewhere around[-0.75, +0.75]"
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.SimpleTimer">
            <summary>
            Simple auto-consuming timer: it will only raise once and invalidate itself (thus never raising again - this
            being the only difference to ManualTimer), after which it has to be reset to be usable again
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IFeeder">
            <summary>
            A 'feeder' is a food/water/milk bowl or anything else that contains these things.' Some background:
            - Feeders are multi-purpose, they should be able to accomodate all currently supported types of food and drink.
            - They are themselves responsible for displaying the current type of food (e.g., beef vs chicken vs milk)
              by configuring their shaders.
            - They also are responsible for their fill status and responding to requests (by beings or gameplay code) to
              fill or empty themselves gradually (0..1).
            - Alex: the interface IWorldAssetContainer is just a guess, change it as you need.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IFeeder.ContainedWorldAssetID">
            <summary>
            Self-explanatory
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IFeeder.FillStatus01">
            <summary>
            How empty or full we are. Has either range [0..1] or {0,1}, depending on whether the contained
            asset is continuously fillable/depletable (e.g. water) or a discrete object (e.g. a treat)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IFeeder.CapacityMl">
            <summary>
            Capacity of this feeder in Milliliters (no matter if used for drink or for food)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IFeeder.HasRelevantContent(System.Single)">
            <summary>
            Does the feeder current content is currently assigned and has higher fill status than the given threshold?
            </summary>
            <param name="fillThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IFeeder.ApplyFillDelta(System.Single)">
            <summary>
            Add or subtract a delta from FillStatus01 immediately.
            <returns> The effective delta applied, which can be different that the given delta</returns>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IShelter">
            <summary>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous">
            <summary>
            TODO
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClientThin.#ctor(VirtualBeings.Tech.BehaviorComposition.Being,VirtualBeings.Tech.ActiveCognition.PathInspector,System.Single)">
            <summary>
            TODO, in the future, don't require a pathInspector parameter, but always use a (fixed)
            version of SucceedWhenCloseToEnd.
            And NB: when *not* using a (any) pathInspector, PF can fail, whereas with use of a pathInspector
            it will always return a path to the closest-point-so-far.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClientThin.GetLengthOfStraightCorridor(UnityEngine.Vector3)">
            <summary>
            Simple wrapper for Pathfinder.GetLengthOfStraightCorridor
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClientThin.TryGetClosestObstacle(System.Single,UnityEngine.Vector3@)">
            <summary>
            Simple wrapper for Pathfinder.GetClosestObstacle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClientThin.TryGetDistToClosestObstacle(System.Single,System.Single@)">
            <summary>
            Another simple wrapper for Pathfinder.GetClosestObstacle
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.IsPathCut">
            <summary>
            Does the last found path go all the way to the goal? Else it is 'cut' (because it's inside an obstacle)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.DistToCollision">
            <summary>
            Get distance before we hit obstacle, range is [-_halfClearance..float.MaxValue]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.GetLengthOfStraightCorridor(UnityEngine.Vector3)">
            <summary>
            Simple wrapper for Pathfinder.GetLengthOfStraightCorridor
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.TryGetClosestObstacle(System.Single,UnityEngine.Vector3@)">
            <summary>
            Simple wrapper for Pathfinder.GetClosestObstacle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.TryGetDistToClosestObstacle(System.Single,System.Single@)">
            <summary>
            Another simple wrapper for Pathfinder.GetClosestObstacle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.NavigationClient.AdjustStepParametersForObstacleAvoidance(System.Single@,System.Single@,System.Single)">
            <summary>
            Specialized method that adjusts the parameters handed to Actuator.Root_DoStep() so that the Being doesnt step into an obstacle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.RegisterGameObjectAsObstacle(UnityEngine.GameObject,System.Single,System.Single)">
            <summary>
            Insert 'go' into the navmesh. If updateFrequencyInSeconds is greater than zero, go's position will
            be automatically tracked and updated in the navmesh with the specified frequency.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.UnregisterGameObjectAsObstacle(UnityEngine.GameObject)">
            <summary>
            Stop tracking 'go' in the navmesh. NB: tracking doesn't stop right away, so dont call Destroy(go) just yet.
            At the moment, there is no guarantee as to when go will actually be unregistered. This shouldn't be an issue
            because the gameobject of an unregistered (i.e., kill-marked) obstacle won't be touched upon actual removal from navmesh.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.IsInNavigableArea(UnityEngine.Vector3,System.Single)">
            <summary>
            Check if a position is inside the navigable area
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.GetWorldSize">
            <summary>
            Returns either length or width of the navigable area, whichever is larger
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ProjectOnXZ(UnityEngine.Vector3)">
            <summary>
            Project a point onto the XZ plane of the root transform of the navigable space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToLocalRotation(UnityEngine.Quaternion)">
            <summary>
            Transform world rotation into a rotation that's in the local space of the navmesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToGlobalRotation(UnityEngine.Quaternion)">
            <summary>
            Transform a rotation that's in the local space of the navmesh into a world rotation
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToLocalVector3(UnityEngine.Vector3)">
            <summary>
            Transform world position into a Vector3 that's in the local space of the navmesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToLocalVector3Vector(UnityEngine.Vector3)">
            <summary>
            Transform world vector into a Vector3 that's in the local space of the navmesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToLocalVec2(UnityEngine.Vector3)">
            <summary>
            Transform world position into a Vec2 that's in the local space of the navmesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToLocalVec2Vector(UnityEngine.Vector3)">
            <summary>
            Transform world vector into a Vec2 that's in the local space of the navmesh
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToGlobalVector3(UnityEngine.Vector3)">
            <summary>
            Transform point in the local space of the navmesh into a Vector3 in world-space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToGlobalVector3Vector(UnityEngine.Vector3)">
            <summary>
            Transform vector in the local space of the navmesh into a Vector3 in world-space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToGlobalVector3(VirtualBeings.Tech.Utils.Vec2,System.Single)">
            <summary>
            Transform point in the local space of the navmesh into a Vector3 in world-space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ToGlobalVector3Vector(VirtualBeings.Tech.Utils.Vec2,System.Single)">
            <summary>
            Transform vector in the local space of the navmesh into a Vector3 in world-space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.GetNextAvailablePositionID">
            <summary>
            Get new ID to efficiently do repeated pathfinds or spatial reasoning. Use new ID for each agent,
            and also new IDs whenever you want to explore space farther away from an registered agent
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.HasChangedAfter(System.DateTime)">
            <summary>
            Check if navmesh has changed since time
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ProcessQueue(System.Single)">
            <summary>
            This method sequentially processes all dynamic obstacles each frame, but only only for
            the specified duration. Note that it intentionally overshoots the allotted time by one transaction
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.NavigationServerSynchronous.ExtractDCDTBoundingBox">
            <summary>
            Helper to get the bounding box of the navigable area, as defined by the box collider on our gameObject
            </summary>
            <returns></returns>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.BinaryReadableWritableField.ID">
            <summary>
            The ID of the field considering the declaring class as its scope.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.BinaryReaderWriter">
            <summary>
            This class contains the logic to read/save data from/to a binary file.
            Classes that support this kind of serialization must define attribute BinaryReadableWritableClass.
            All the fields of the class that is intended to be serialized must also define a custom attribute: BinaryReadableWritableField.
            Each field must defined an ID that must be unique during the whole lifetime of the application.
            The scope of the ID of a field is the class where the field is defined.
            The type of the field cannot be changed during the lifetime of the application.
            However, if the type of the field is a custom class (defined with attribute BinaryReadableWritableClass), fields for that custom class type can be added or removed.
            Therefore, a field that is no longer used in the source code can be safely removed from the source code. Just make sure that the ID of this field is never used in the future when declaring a new field in that class.
            Also, a custom class type (defined with attribute BinaryReadableWritableClass) that is no longer needed in the source code can also be safely deleted.
            By following these simple rules, we support the possibility of loading safely into memory a binary file that was generated using an old version of the source code.
            Supported types for now:
                1. Primitive types: int, long, float, double, byte, char, string, bool, Vector3, Quaternion, DateTime.
                2. Custom user class/struct types: classes/structs defined with attribute BinaryReadableWritableClass/BinaryReadableWritableStruct.
                3. Custom user enums.
                4. One dimension arrays or List of any of types mentioned from 1 to 4 (yes, 4 included).
            Special case of a null reference is also supported.
            
            
            Why our solution is somehow better than .Net BinaryFormatter?
            Well, in our solution, we can delete fields that we dont need anymore in our code and still load safely.
            We can also rename fields as long as we keep their ID. Rename fields is something that happen a lot during the lifetime of an application.
            These two points would give us problem if we used BinaryFormatter as explained in section "Best practices":
            https://docs.microsoft.com/en-us/dotnet/standard/serialization/version-tolerant-serialization
            
            Current limitation: we basically serialize the data as value types.
            So if an object holds two fields that are the same reference, after deserializing the data, the two fields are two different references.
            In the future, we can improve this class by tracking the references to be serialized.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.PlatformState">
            <summary>
            Describe the current platform (Mobile, AR, VR, ...)
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Easings.PI">
            <summary>
            Constant Pi.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.Easings.HALFPI">
            <summary>
            Constant Pi / 2.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.Easings.Functions">
            <summary>
            Easing Functions enumeration
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.Interpolate(System.Single,VirtualBeings.Tech.UnityIntegration.Easings.Functions)">
            <summary>
            Interpolate using the specified function.
            NB: p is not clamped, result is undefined if p isn't in [0..1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.EarlyOnset(System.Single)">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.DelayedOnset(System.Single)">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.Suppression(System.Single,System.Single)">
            <summary>
            Addition:
            Returns 1 when p is between q and 1-q; fades result in/out quadratically before/after that
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuadraticEaseIn(System.Single)">
            <summary>
            Modeled after the parabola y = x^2
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuadraticEaseOut(System.Single)">
            <summary>
            Modeled after the parabola y = -x^2 + 2x
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuadraticEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise quadratic
            y = (1/2)((2x)^2)             ; [0, 0.5)
            y = -(1/2)((2x-1)*(2x-3) - 1) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CubicEaseIn(System.Single)">
            <summary>
            Modeled after the cubic y = x^3
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CubicEaseOut(System.Single)">
            <summary>
            Modeled after the cubic y = (x - 1)^3 + 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CubicEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise cubic
            y = (1/2)((2x)^3)       ; [0, 0.5)
            y = (1/2)((2x-2)^3 + 2) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuarticEaseIn(System.Single)">
            <summary>
            Modeled after the quartic x^4
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuarticEaseOut(System.Single)">
            <summary>
            Modeled after the quartic y = 1 - (x - 1)^4
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuarticEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise quartic
            y = (1/2)((2x)^4)        ; [0, 0.5)
            y = -(1/2)((2x-2)^4 - 2) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuinticEaseIn(System.Single)">
            <summary>
            Modeled after the quintic y = x^5
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuinticEaseOut(System.Single)">
            <summary>
            Modeled after the quintic y = (x - 1)^5 + 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.QuinticEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise quintic
            y = (1/2)((2x)^5)       ; [0, 0.5)
            y = (1/2)((2x-2)^5 + 2) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.SineEaseIn(System.Single)">
            <summary>
            Modeled after quarter-cycle of sine wave
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.SineEaseOut(System.Single)">
            <summary>
            Modeled after quarter-cycle of sine wave (different phase)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.SineEaseInOut(System.Single)">
            <summary>
            Modeled after half sine wave
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CircularEaseIn(System.Single)">
            <summary>
            Modeled after shifted quadrant IV of unit circle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CircularEaseOut(System.Single)">
            <summary>
            Modeled after shifted quadrant II of unit circle
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.CircularEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise circular function
            y = (1/2)(1 - Mathf.Sqrt(1 - 4x^2))           ; [0, 0.5)
            y = (1/2)(Mathf.Sqrt(-(2x - 3)*(2x - 1)) + 1) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ExponentialEaseIn(System.Single)">
            <summary>
            Modeled after the exponential function y = 2^(10(x - 1))
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ExponentialEaseOut(System.Single)">
            <summary>
            Modeled after the exponential function y = -2^(-10x) + 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ExponentialEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise exponential
            y = (1/2)2^(10(2x - 1))         ; [0,0.5)
            y = -(1/2)*2^(-10(2x - 1))) + 1 ; [0.5,1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ElasticEaseIn(System.Single)">
            <summary>
            Modeled after the damped sine wave y = sin(13pi/2*x)*Mathf.Pow(2, 10 * (x - 1))
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ElasticEaseOut(System.Single)">
            <summary>
            Modeled after the damped sine wave y = sin(-13pi/2*(x + 1))*Mathf.Pow(2, -10x) + 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.ElasticEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise exponentially-damped sine wave:
            y = (1/2)*sin(13pi/2*(2*x))*Mathf.Pow(2, 10 * ((2*x) - 1))      ; [0,0.5)
            y = (1/2)*(sin(-13pi/2*((2x-1)+1))*Mathf.Pow(2,-10(2*x-1)) + 2) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BackEaseIn(System.Single)">
            <summary>
            Modeled after the overshooting cubic y = x^3-x*sin(x*pi)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BackEaseOut(System.Single)">
            <summary>
            Modeled after overshooting cubic y = 1-((1-x)^3-(1-x)*sin((1-x)*pi))
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BackEaseInOut(System.Single)">
            <summary>
            Modeled after the piecewise overshooting cubic function:
            y = (1/2)*((2x)^3-(2x)*sin(2*x*pi))           ; [0, 0.5)
            y = (1/2)*(1-((1-x)^3-(1-x)*sin((1-x)*pi))+1) ; [0.5, 1]
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BounceEaseIn(System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BounceEaseOut(System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Easings.BounceEaseInOut(System.Single)">
            <summary>
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IGuard">
            <summary>
            What are guards? Basically, just stateful predicates. So a guard takes a predicate and turns it
            into a new, enriched predicate that can be aware of state. For example, it can take a predicate
            and terminate if the predicate has been false consistently for the last 2 seconds. Or it can
            chain predicates temporally (rather than just logically) and terminate once the second predicate
            is false after the first has evaluated to false at least once. And so on.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IGuard.GetGuard">
            Must be called before use
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.GuardWithMinDuration">
            <summary>
            This guard terminates once its predicate fails consistently for a period of length
            'duration', which is randomized upon reset (within bounds given in constructor).
            NB: The predicate is the condition we expect to be true - and while it is, the guard continues.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.GuardWithMinDuration.Initialize">
            <summary>
            Must be called before use
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.GuardWithMinDuration.Continue">
            <summary>
            Interpret as 'not IsRaised()'.
            NB: can be called multiple times per frame or over skipped frames (where the latter count as fails).
            NB: after returning false, the guard may be used in subsequent frames and then possibly return true again.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.GuardWithCumulativeFail">
            <summary>
            This guard terminates once its weighted predicate failures exceed 'thresholdInSeconds'; the (linear!) weight of each
            predicate failure or success is 'deltaTime'.
            The earliest termination point (continuous streak of predicate fails) is therefore at time t = thresholdInSeconds.
            NB: The predicate is the condition we expect to be true - and while it is, the guard continues.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.GuardWithCumulativeFail.Initialize">
            <summary>
            Must be called before use
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.GuardWithCumulativeFail.Continue">
            <summary>
            Interpret as 'not IsRaised()'.
            NB: can be called multiple times per frame or over skipped frames
            NB: after returning false, the guard may be used in subsequent frames and then possibly return true again.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.SpatialDB">
            <summary>
            This spatial database keeps track of objects (IInteractables that aren't agents or extremities) and agents separately.
            It's responsible for keeping the Velocity fields of all of them updated
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.SpatialDB.GetEntities(VirtualBeings.Tech.UnityIntegration.IInteractable,VirtualBeings.Tech.UnityIntegration.IFOVProvider,VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.UnityIntegration.IInteractable},System.Boolean,System.Boolean,System.Func{VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean})">
            <summary>
            TODO
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IEnvironmentMover">
            <summary>
            Allow an entity to be rotated by a hook (e.g., via a hand controller in VR)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IEnvironmentMover.UpdateControlData(UnityEngine.Vector3,System.Single,UnityEngine.Vector3@)">
            <summary>
            Can (but does not have to) be called once per frame
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IGameManager.WorldEvents">
            Various things
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.InteractableProperty.Static">
            Do not change order of existing items, it might mess up serialization in Unity
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.IInteractable">
            <summary>
            Base interface for interactables. Note that interactables can be
            found via their children, which must have been registered via InteractionDB.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.TopLevelParent">
            <summary>
            What's the gameobject and transform that 'own' this Interactable?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsDestroyed">
            <summary>
            Has the underlying gameobject been destroyed by Unity?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.CenterPosition">
            <summary>
            Center of the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.CenterRotation">
            <summary>
            Rotation at the center of the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.SalientPosition">
            <summary>
            Position to look at (e.g., the head/eyes for agents)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.RootPosition">
            <summary>
            Root position of the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.RootRotation">
            <summary>
            Root rotation of the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsLocalizable">
            <summary>
            Is this interacstable visible or does it have a localizable audio source?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsLocal">
            <summary>
            For single-player: always true.
            For multiplayer: true if the present device is hosting this interactable.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.MaxRadius">
            <summary>
            Maximum radius of the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Height">
            <summary>
            Height of the interactable bounding box when it's rotation is identity.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Width">
            <summary>
            Width of the interactable bounding box when it's rotation is identity.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Length">
            <summary>
            Length of the interactable bounding box when it's rotation is identity.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsDynamic">
            <summary>
            Is this interactable able to move after being spawned?
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.InteractionMode">
            <summary>
            If non-null, the interaction mode that's active for the interactable
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsHandled">
            <summary>
            True iff Handler is non-null
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Handler">
            <summary>
            If non-null, the interactable that 'handles' the current one, e.g. by grabbing, holding, parenting etc.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.SetHandler(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Assign a new handler to this interactable
            </summary>
            <param name="handler">Must be non-null</param>
            <returns>True if Handler is now <paramref name="handler"/></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.ReleaseHandler(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Release the interactable from being handled
            </summary>
            <param name="handlerToReleaseFrom">Optional</param>
        </member>
        <member name="E:VirtualBeings.Tech.UnityIntegration.IInteractable.OnHandlerChanged">
            <summary>
            Event that's fired if Handler has been effectively changed
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.IsInPlacementMode">
            <summary>
            Is this interactable currently in 'placement mode'? (This is currently only used in Tender Paws and might evolve)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.IsInInteractionDB">
            <summary>
            Is the interactable registered in the interaction database?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.HasProperty(VirtualBeings.Tech.UnityIntegration.InteractableProperty)">
            <summary>
            True if interactable has indeed the given property.
            NB: if properties are kept in a collection, they should be stored as int to avoid boxing
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Properties">
            <summary>
            Used internally, never null. NB: must not be changed at runtime and must not be referenced between frames
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.GetNearestPointOnSurface(UnityEngine.Vector3)">
            <summary>
            Get the point on the interactable that's closest to referencePoint
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IInteractable.Destroy(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            Kill owning gameobject
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.DestroyedBy">
            <summary>
            Null, unless the interactable (together with its owning GO) were actually destroyed by an agent
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.Velocity">
            <summary>
            Administered by SpatialDB, get but dont set manually (exception: IAgent)
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.___PrevPosition">
            <summary>
            Administered by SpatialDB, *dont use*
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.CorrectiveDelta">
            <summary>
            Should only be read by SpatialDB.
            Normally left alone; *can* be set by (e.g. touch controller) *per frame* to make SpatialDB correct Velocity.
            This is useful to avoid making virtual beings aware of camera movements on flat-screen devices (because
            they are distractable and will often look at the moving camera).
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.IInteractable.InteractableID">
            <summary>
            Used for networking purposes. Each interactable must have a unique ID,
            and it must be the same between all instances of an interactable in a network configuration.
            All positive values are free to use. Negatives are reserved.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.InteractionDB">
            <summary>
            This class is essentially a database where GameObjects (or sets of GameObjects) can register the
            IInteractable interfaces implemented by MonoBehaviors on their top-level GameObject. The database
            can be efficiently (O(1)) queried to find out which IInteractable interfaces are offered by a given
            GameObject (or it's top-level parent), and to list *all* objects that implement an IInteractable of a given sub-type
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.HasInteractables(UnityEngine.GameObject)">
            <summary>
            Check if 'go' *or* it's top-level parent have been registered as offering any IInteractable interfaces
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.HasInteractable(UnityEngine.GameObject,System.Type)">
            <summary>
            Check if an interactable interface is offered by 'go' *or* it's top-level parent
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.GetAllInteractables(UnityEngine.GameObject)">
            <summary>
            Return a dictionary of all interactables supported by the top-level parent of 'go'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.IsInDatabase(VirtualBeings.Tech.UnityIntegration.IInteractable,System.Type)">
            <summary>
            Check if an interactable is in the database (via the given interactableType)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.TryGetInteractable(UnityEngine.GameObject,System.Type,VirtualBeings.Tech.UnityIntegration.IInteractable@)">
            <summary>
            Try to get an interactable interface offered by 'go' *or* it's top-level parent
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.GetInteractablesOfType(System.Type)">
            <summary>
            Return a set of all GameObjects that offer implementations of IInteractable interfaces of type 'interactableType'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.FindFirst(System.Type,System.Func{VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean},System.Int32)">
            <summary>
            Return the first match of a type that satisfies a predicate
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.FindAll(System.Type,System.Func{VirtualBeings.Tech.UnityIntegration.IInteractable,System.Boolean},System.Collections.Generic.IList{VirtualBeings.Tech.UnityIntegration.IInteractable},System.Int32)">
            <summary>
            Return all matches that satisfy a predicate
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.RegisterChild(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            This method registers children of a parent GameObject which offers IInteractable interfaces. Use this so that
            a child (e.g. with a collider) can be used by an interaction partner to see if it is interactive.
            NB: it's not necessary to register the top-level parent as it's own parent
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.RegisterInteractable``1(UnityEngine.GameObject,``0)">
            <summary>
            Call this method once for each type of IInteractable interface offered by a GameObject and its children
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractionDB.UnregisterInteractable``1(UnityEngine.GameObject,``0)">
            <summary>
            Unregister a single IInteractable interface currently offered by a GameObject.
            NB: 'topLevelParent' (and references to its children) will be removed completely from
            the database if it's currently not offering any other types of IInteractable interfaces
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ITouchResponder">
            <summary>
            Process touch input (e.g., from a hand rig in VR)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ITouchResponder.AcceptTouchThisFrame">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ITouchResponder.UpdateTouchData(VirtualBeings.Tech.UnityIntegration.IAgent,VirtualBeings.Tech.UnityIntegration.IInteractable,UnityEngine.Collider,System.Single,VirtualBeings.Tech.Utils.Set{UnityEngine.Collider},System.Single@,System.Single@,System.Boolean@)">
            <summary>
            Called by a touching interactable (such as a virtual hand) per frame to inform the being about the touch.
            </summary>
            <param name="agent">Which agent is ultimately responsible for the touch?</param>
            <param name="source">What interactable is responsible (e.g. a hand)</param>
            <param name="touching">The collider on <paramref name="source"/></param>
            <param name="maxRadiusOfTouchingCollider">What is the *visual* maximum radius of the touching collider? This is subtracted from the actual
            interpenetration depth of the two colliders to determine if a touching collider is visually inside or outside the being.</param>
            <param name="setTouched">A set of all colliders touched on this being</param>
            <param name="displacement01">Out parameter to tell the touching object how far it displaces the agent (normalized).
            This is useful on touchscreen devices where touch pressure or depth isn't available.</param>
            <param name="penetration01">Out parameter to tell the touching object how far it penetrates into the being (normalized).
            Note that a value above 0 implies that <paramref name="displacement01"/> has reached 1.</param>
            <param name="flagPenetration">Whether a threat event was posted internally due to ongoing penetration</param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.ITouchResponder.OnPoke(VirtualBeings.Tech.UnityIntegration.IAgent,VirtualBeings.Tech.UnityIntegration.IInteractable,UnityEngine.Collider,UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            <summary>
            TODO needs refactoring for 6DoF pokes
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.InteractableController">
            <summary>
            Class to be used by gameObject to become part of interaction system.
            /// </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.InteractableController._obstacleType">
            Fields serialized by Unity
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableController.OnEnable">
            <summary>
            Must be called by owning gameObject
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.InteractableController.TopLevelParent">
            IInteractable implementation
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableController.SetHandler(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            This implementation always returns true
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableController.ReleaseHandler(VirtualBeings.Tech.UnityIntegration.IInteractable)">
            <summary>
            Free the interactable from its current handler.
            </summary>
            <param name="handlerToReleaseFrom">If null, then Handler will be nulled in any case</param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.InteractableController.Destroy(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            Kill owning gameObject
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IAgent.CanAttach(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            Somebody asks if they can 'attach' to us
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IAgent.OnAttach(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            We responded positively to RequestAttachment(), no actual attachment takes place
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IAgent.OnDetach(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            Attacher now detaches from us
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.IAgent.DemandDetachment(VirtualBeings.Tech.UnityIntegration.IAgent)">
            <summary>
            We're attached to someone who now wants us to stop
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.WorldEvent_Info">
            <summary>
            Used by interactables to inform world about an event or intention with potential gameplay relevance.
            E.g., when player picks up a ball, the ball can fire this event to notify all beings that it
            should be monitored (and fire again with EstimatedDuration = -1 when its let go).
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.WorldEvent_InteractableIsHandled">
            <summary>
            Sent when an IInteractable starts handling another IInteractable
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.WorldEvent_MotiveSatisfied.Being">
            <summary>
            Whose motive was satisfied?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.WorldEvent_MotiveSatisfied.MotiveIndex">
            <summary>
            Which motive was satisfied?
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.WorldEvent_MotiveSatisfied.Satisfied">
            <summary>
            Was the motive satisfied or dissatisfied
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.WorldEvent_MotiveSatisfied.SatisfiedBy">
            <summary>
            Which agent satisfied this motive for this being? Can be null. Can also be (main) player.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.WorldEvent_SoundRequest.Poignancy01">
            the *emotional* poignancy of the sound (to inform receivers of a SoundEvent), i.e. the
            degree to which it demands attention at or below 'reference distance' (i.e., ignoring AudioSource volume)
            (NB: 'reference distance' is configured in SoundTrackerCogSettings)
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.PlaneCount">
            <summary>
            The number of planes in the frustum.
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.CornerCount">
            <summary>
            The number of corner points in the frustum.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.Position">
            <summary>
            Returns the current position of the frustum
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum._corners">
            <summary>
            Ordering: [0] = Far Bottom Left, [1] = Far Top Left, [2] = Far Top Right, [3] = Far Bottom Right,
            [4] = Near Bottom Left, [5] = Near Top Left, [6] = Near Top Right, [7] = Near Bottom Right
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum._planes">
            <summary>
            Defines the set of planes that bound the camera's frustum. All plane normals point to the inside of the
            frustum.
            Ordering: [0] = Left, [1] = Right, [2] = Down, [3] = Up, [4] = Near, [5] = Far
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum._absNormals">
            <summary>
            Caches the absolute values of plane normals for re-use during frustum culling of multiple AABB instances
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum._planeNormal">
            <summary>
            Caching the plane normals allows the culling code to avoid calling property getters on the Plane instances
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.UnityIntegration.BoundingFrustum._planeDistance">
            <summary>
            Caching the plane distances allows the culling code to avoid calling property getters on the Plane instances
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetCorners(UnityEngine.Vector3[])">
            <summary>
            Extracts the frustum corners. The destination array must contain space for no less than CornerCount elements.
            Ordering: [0] = Far Bottom Left, [1] = Far Top Left, [2] = Far Top Right, [3] = Far Bottom Right, [4] = Camera Position
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetPlanes(UnityEngine.Plane[])">
            <summary>
            Extracts the frustum planes. The destination array must contain space for no less than PlaneCount elements.
            Ordering: [0] = Left, [1] = Right, [2] = Down, [3] = Up, [4] = Near, [5] = Far
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.Update(UnityEngine.Camera)">
            <summary>
            Update the bounding frustum from the current camera settings
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.Update(UnityEngine.Camera,System.Single)">
            <summary>
            Update the bounding frustum from the current camera settings
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.Update(UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Update the bounding frustum
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.DebugDraw(UnityEngine.Color,System.Single)">
            <summary>
            Visualize the frustum
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.Contains(UnityEngine.Vector3)">
            <summary>
            Returns true if the frustum contains the specified point
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetSphereIntersection(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Returns the type of intersection (if any) between the frustum and the sphere
            </summary>
            <param name="center">The world position of the sphere</param>
            <param name="radius">The radius of the sphere</param>
            <param name="frustumPadding"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetSphereIntersection(UnityEngine.BoundingSphere,System.Single)">
            <summary>
            Returns the type of intersection (if any) between the frustum and the sphere
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.CullSpheres(VirtualBeings.Tech.UnityIntegration.BoundingFrustum.CullingSphere[],System.Int32)">
            <summary>
            Iterates through each sphere in the array and sets the Result field to the result of the sphere/frustum intersection test
            This function is intended primarily for use with static geometry (or quadtrees, etc) where the bounding volumes will not
            be updated frequently, but the frustum will.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.IntersectsSphere(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Returns the type of intersection (if any) between the frustum and the sphere
            </summary>
            <param name="center">The world position of the sphere</param>
            <param name="radius">The radius of the sphere</param>
            <param name="frustumPadding"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.IntersectsSphere(UnityEngine.BoundingSphere,System.Single)">
            <summary>
            Returns the type of intersection (if any) between the frustum and the sphere
            </summary>
            <param name="sphere">The sphere to check</param>
            <param name="frustumPadding"></param>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.IntersectsBox(UnityEngine.Bounds,System.Single)">
            <summary>
            Returns TRUE if the box and frustum intersect
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetBoxIntersection(UnityEngine.Bounds,System.Single)">
            <summary>
            Returns the type of intersection (if any) between the bounding box and the frustum
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.CullBoxes(VirtualBeings.Tech.UnityIntegration.BoundingFrustum.CullingBox[],System.Int32)">
            <summary>
            Iterates through each box in the boxes array and sets the Result field to the result of the box/frustum intersection test.
            This function is intended primarily for use with static geometry (or quadtrees, etc) where the bounding volumes will not
            be updated frequently, but the frustum will.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.IntersectsOrientedBox(UnityEngine.Bounds,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Returns TRUE if the oriented bounding box and frustum intersect
            </summary>
            <param name="box">The bounding box to test. Note: box.center is expected to be in world coordinates</param>
            <param name="right">The horizontal local coordinate axis (equivalent to Transform.right)</param>
            <param name="up">The vertical local coordinate axis (equivalent to Transform.up)</param>
            <param name="forward">The forward local coordinate axis (equivalent to Transform.forward)</param>
            <param name="frustumPadding"></param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.BoundingFrustum.GetOrientedBoxIntersection(UnityEngine.Bounds,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Returns the type of intersection (if any) of an oriented bounding box and the frustum.
            </summary>
            <param name="box">The bounding box to test. Note: box.center is expected to be in world coordinates</param>
            <param name="right">The horizontal local coordinate axis (equivalent to Transform.right)</param>
            <param name="up">The vertical local coordinate axis (equivalent to Transform.up)</param>
            <param name="forward">The forward local coordinate axis (equivalent to Transform.forward)</param>
            <param name="frustumPadding"></param>
            <returns></returns>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AutoCounter">
            <summary>
            Counter that raises a flag after being queried a random number of times (but within specified bounds)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.ManualTimer">
            <summary>
            Simple class that encapsulates a reusable, but NOT auto-consuming timer (i.e., once raised
            it will remain so until reset)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.AutoTimer">
            <summary>
            A timer that resets itself to a new time as soon it is raised.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.AutoTimer.Reset(System.Single,System.Single,System.Boolean)">
            <summary>
            NB: startRaised is not part of the state, i.e. calling Reset() (w/out parameters) will never start as raised
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Constraint.PrepareRecalculation">
            <summary>
            Set all member variables used for hull recalculation, so that no transforms etc
            have to be access from a worker thread
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Constraint.Calculate2DHull(VirtualBeings.Tech.Utils.PolyLine)">
            <summary>
            Calculate the 2D hull for use in the DCDT.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.State`2">
            <summary>
            An abstract base class for states of user-defined state-machines
            </summary>
            <typeparam name="T">An enum for the states of the state machine</typeparam>
            <typeparam name="U">An event type</typeparam>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.GenericStateMachine`2">
            <summary>
            A generic class for user-defined state machines
            </summary>
            <typeparam name="T">An enum for the states of the state machine</typeparam>
            <typeparam name="U">An event type, used in State.ProcessEvent above</typeparam>
        </member>
        <member name="P:VirtualBeings.Tech.UnityIntegration.Rand.sign">
            <summary>
            Returns either -1 or 1, never 0
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Rand.Range(System.Int32,System.Int32)">
            <summary>
            Returns int between min (inclusive) and max (exclusive)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Misc.LayerMaskToLayer(UnityEngine.LayerMask)">
            <summary>
            Converts given bitmask to layer number.
            Only gives correct result if the mask has a single bit set.
            From https://forum.unity.com/threads/get-the-layernumber-from-a-layermask.114553/#post-3021162
            </summary>
            <returns> layer number </returns>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Misc.DrawDebugPoint(UnityEngine.Vector3,System.Single,UnityEngine.Color,System.Single,System.Single)">
            <summary>
            Debug-draw a point in space
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Misc.SinePlusCosine(System.Single)">
            <summary>
            Calculates the sum of sine + cosine of an angle using a single trigonometric calculation.
            See https://trans4mind.com/personal_development/mathematics/trigonometry/sumProductCosSin.htm#Sum_of_Sine_and_Cosine
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Misc.FindComponentInScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
            Like GetComponentInChildren(), but over an entire scene
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Misc.PredictTimeToCollisionOnXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Simple prediction of the time t in which point p1 with velocity v1 will reach point p2 which has velocity v2.
            Not accurate for lateral movements
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vec2Extensions.ToVector3(VirtualBeings.Tech.Utils.Vec2,System.Single)">
            <summary>
            Convert VirtualBeings' Vec2 to Unity's Vector3 (via extension so Vec2 doesnt have to reference UnityEngine)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ToVec2(UnityEngine.Vector3)">
            <summary>
            Convert Vector3 to Vec2
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.AngleProjected(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Project vectors 'this' and 'to' on plane defined by normal and calculate angle in degrees.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.SignedAngleProjected(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Project vectors 'this' and 'to' on plane defined by normal and calculate signed angle in degrees (positive is right, negative is left).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ProjectMagnitude(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Project a vector on normal but retain its magnitude
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.SignedAngle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Calculate signed angle in degrees between vectors 'this' and 'to' w.r.t. axis 'up': angle will be positive if 'to' is right of 'this', negative otherwise
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.Sign3D(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Calculate sign of angle between 'this' and 'to' w.r.t. axis 'up': 1 if 'to' is right of 'this', -1 if left, 0 if collinear
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.WrapAngles(UnityEngine.Vector3)">
            <summary>
            Ensure that all angles are wrapped from -360-360 degrees to -180-180 degrees.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ClampAngles(UnityEngine.Vector3,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Wrap and clamp euler angles. See MMath.ClampAngle() for more.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ClampY(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Clamp y component of a Vector3
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ToLocalPos(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Transform a world-space position into local space using an origin and a rotation. Useful inside animation jobs.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ToWorldPos(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Transform a local-space position into world space using an origin and a rotation. Useful inside animation jobs.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.OnXZ(UnityEngine.Vector3)">
            <summary>
            Zero out y component of Vector3
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ReplaceY(UnityEngine.Vector3,System.Single)">
            <summary>
            Zero out y component of Vector3
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.RotateAround(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Vector3 version of Transform.RotateAround, usable only for vectors, not positions or rotations
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.RotateAround(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Vector3 version of Transform.RotateAround, usable only for positions/vectors, not rotations
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.DistanceToLine(UnityEngine.Vector3,UnityEngine.Ray)">
            <summary>
            Calculate point-to-line distance in 3D, see http://answers.unity3d.com/questions/62644/distance-between-a-ray-and-a-point.html
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ProjectOntoLine(UnityEngine.Vector3,UnityEngine.Ray)">
            <summary>
            Project point onto line and return it, see http://answers.unity3d.com/questions/62644/distance-between-a-ray-and-a-point.html
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ProjectOntoLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Project onto line and return projection, see https://gamedev.stackexchange.com/questions/72528/how-can-i-project-a-3d-point-onto-a-3d-line
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.IsLinePointOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Test if a point on line AB is also on line segment AB.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.IsCloserToAThanB(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Self-explanatory; no assumptions are made about the 3 points.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.DistToSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            See http://geomalgorithms.com/a02-_lines.html
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ClosestPointOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            See http://geomalgorithms.com/a02-_lines.html
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.TryGetProjectionOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@)">
            <summary>
            Wrapper to get the projection of a point onto a segment, if it exists.
            Will return the correctly projected point in any case.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.ThirdPointOfRightTriangle(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
            <summary>
            Project 'this' on the plane defined by center and normal, and then find a tangent point for 'this'
            on the circle defined by center, normal and radius. If 'this' is inside the circle, get the closest
            point on the circle. Otherwise, there's two possible tangent point, and this method always returns
            the one that is in the positive sense of rotation along the normal axis (left-hand rule).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes a vector towards a desired goal over time.
            (From Unity's GitHub - moved here for debuggability)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.Vector3Extensions.SmoothDampWithOvershoot(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes a vector towards a desired goal over time; no overshoot prevention, like in the original code by Thomas Lowe.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.QuaternionExtensions.RelativeRotation(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Calculate the shortest 'difference' between two rotations, more precisely:
            the shortest rotation relrot such that: this * relrot = to.
            NB: this is also the correct method for calculating 'local' rotations (i.e., 'to' in the space of 'from')
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.QuaternionExtensions.Normalized(UnityEngine.Quaternion)">
            <summary>
            Normalizes a quaternion. Throws error if quaternion is zero.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.QuaternionExtensions.ClampAngle(UnityEngine.Quaternion,System.Single,System.Boolean)">
            <summary>
            Returns a version of 'this' whose total rotation (in degrees) is no more than maxAngle.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.QuaternionExtensions.ClampAngles(UnityEngine.Quaternion,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Wrap and clamp euler angles of Quaternion. See MMath.ClampAngle() for more.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.QuaternionExtensions.IsAlmostEqualTo(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
            <summary>
            Quickly compares to normalized quaternions for epsilon-equality using dot-product
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.UnityIntegration.SuspendWorker">
            <summary>
            Simple wrapper for SuspendWhile. Auto-terminates wrapped worker (process or behavior).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.SuspendWorker.#ctor(VirtualBeings.Tech.BehaviorComposition.IWorker,System.Single,System.Single,System.Single)">
            <summary>
            Simple wrapper for SuspendWhile. Auto-terminates wrapped worker (process or behavior).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.UnityIntegration.SuspendWorker.#ctor(VirtualBeings.Tech.BehaviorComposition.IWorker,System.Func{System.Boolean},System.Single,System.Single,System.Single)">
            <summary>
            Simple wrapper for SuspendWhile. Auto-terminates wrapped worker (process or behavior).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ExtensibleEnum`1.FromID(System.Int32)">
            Public interface
            <summary>
            Return the ExtensibleEnum that corresponds to the given ID.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ExtensibleEnum`1.FromName(System.String)">
            <summary>
            Return the ExtensibleEnum that corresponds to the given Name.
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ExtensibleEnum`1.GetRandomNonZero">
            <summary>
            Get a random T, except the one with ID == 0 (usually 'None' or 'Default')
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Utils.ExtensibleEnum`1.All">
            <summary>
            All enum values of type T
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Utils.ExtensibleEnum`1.AllExceptDefault">
            <summary>
            All enum values of type T except for the None/Default one
            </summary>
        </member>
        <member name="F:VirtualBeings.Tech.Utils.ExtensibleEnum`1._dictIdsToInstances">
            Internals
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ExtensibleEnumBase">
            <summary>
            An extensible enum class. Has most of the advantages of enum, plus extensibility via subclass. Based on:
            https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/enumeration-classes-over-enum-types
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.ExtensibleEnumBase.ID">
            Public interface
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ExtensibleEnumBase.#ctor(System.Int32,System.String)">
            Internals
            <summary>
            Standard constructor
            </summary>
            <param name="id">Can be arbitrary, as long as it's unique</param>
            <param name="name">Corresponds to name of 'enum', used for ToString() and for things like FromName in derived classes</param>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.MMath">
            <summary>
            A receptacle for some simple mathematical utilities - provided
            here for the sake of platform independence.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Clamp``1(``0,``0,``0)">
            <summary>
            Clamp the specified value between min (inclusive) and max (inclusive).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Clamp01(System.Single)">
            <summary>
            Clamp the specified float between 0 and 1.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Clamp0100(System.Single)">
            <summary>
            Clamp the specified float between 0 and 100.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation, t will be clamped between 0 and 1
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.LerpUnclamped(System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation, t will not be clamped
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.InverseLerp(System.Single,System.Single,System.Single)">
            <summary>
            Calculates the Lerp parameter between two values.
            Copied from Unity sources as a reminder that it does use Clamp01 (undocumented).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Max``1(System.Collections.Generic.List{``0})">
            <summary>
            Find the maximum in an unsorted array
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Min``1(System.Collections.Generic.List{``0})">
            <summary>
            Find the minimum in an unsorted array
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.SetBit(System.Int32,System.Byte)">
            <summary>
            Methods for handling bit masks
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.WrapAngle(System.Single)">
            <summary>
            Ensure that an angle (in degrees) of any amount is wrapped to -180-180 degrees.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.AbsAngle(System.Single,System.Single)">
            <summary>
            Return the smallest angle between two (already wrapped) angles. Result is less than or equal to 180f
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.ClampAngle(System.Single,System.Single,System.Single,System.Boolean@)">
            <summary>
            Robust clamping of angle (in degs). First all three parameters are wrapped.
            Then if min is less or equal max, angle is clamped as usual. If max is less than min then
            angle is clamped 'over' the singularity point +/-180.
            NB: angular clamping is ambiguous if angle is outside the range min-max. When this is the
            case, this function returns whichever value of min, max is closer to angle (on the circle).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.ClampAngle(System.Single,System.Single,System.Single)">
            <summary>
            Robust clamping of angle (in degs). First all three parameters are wrapped.
            Then if min is less or equal max, angle is clamped as usual. If max is less than min then
            angle is clamped 'over' the singularity point +/-180.
            NB: angular clamping is ambiguous if angle is outside the range min-max. When this is the
            case, this function returns whichever value of min, max is closer to angle (on the circle).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.SignNonZero(System.Double)">
            <summary>
            Similar to Math.Sign(), but returns 1 if parameter is zero
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Sign(System.Double)">
            <summary>
            A version of the Sign function that will return 0 when handed NaN (rather throw an ArithmeticException)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Sign(System.Single)">
            <summary>
            A version of the Sign function that will return 0 when handed NaN (rather throw an ArithmeticException)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.AngularLerp(System.Single,System.Single,System.Single)">
            <summary>
            With both from and to ranging [-180f..180f], return the clamped linear
            interpolation on the shorter of the two circular paths between from and to.
            t01 is *not* clamped.
            NB: Mathf.LerpAngle() is underdocumented so I don't know if it behaves the same.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes a value towards a desired goal over time.
            (From Unity's GitHub - moved here for debuggability)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.SmoothDampWithOvershoot(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes a value towards a desired goal over time; no overshoot prevention, like in the original code by Thomas Lowe.
            NB: smoothTime: "Approximately the time it will take to reach the target. A smaller value will reach the target faster."
            Lowe explains that smoothTime can also be seen as lag - higher value means more lag.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes an angle given in degrees towards a desired goal angle over time.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.DeltaAngle(System.Single,System.Single)">
            <summary>
            Calculates the shortest difference between two given angles.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.MMath.Repeat(System.Single,System.Single)">
            <summary>
            Loops the value t, so that it is never larger than length and never smaller than 0.
            (From Unity's GitHub - moved here for debuggability)
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ParametricSteeringManager">
            <summary>
            The purpose of ParametricSteeringManager is to keep a list of IParametricSteering objects,
            and to update them in a resource-conscious manner. To activate steering on an object, use Add()
            (multiple adds have no effect if an object is still active). Then the object will be updated until
            its UpdateOncePerFrame() method returns false.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ConvexHull">
            <summary>
            A class to compute the convex hull of a set of points in the plane.
            Uses a well-known method: the Graham scan with points presorted radially
            around the lowest point of the set. Partially based on anonymous code on the net.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ConvexHull.#ctor">
            <summary>
            Class cannot be instantiated
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ConvexHull.GetConvexHull(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},VirtualBeings.Tech.Utils.PolyLine,VirtualBeings.Tech.Utils.ConvexHull.RadialComparator,System.Double)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ConvexHull.SortRadiallyAndRemoveDuplicates(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},System.Double,VirtualBeings.Tech.Utils.ConvexHull.RadialComparator)">
            <summary>
            Does what it says
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ConvexHull.GrahamScan(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},VirtualBeings.Tech.Utils.PolyLine)">
            <summary>
            See https://en.wikipedia.org/wiki/Graham_scan
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ConvexHull.RadialComparator">
            <summary>
            Compares two Vec2's for their polar angle relative to an origin; assumed that polar angle ascends CCW
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.#ctor(System.Single,UnityEngine.Vector3,System.Single)">
            <summary>
            Constructor for the point octree.
            </summary>
            <param name="initialWorldSize">Size of the sides of the initial node. The octree will never shrink smaller than this.</param>
            <param name="initialWorldPos">Position of the centre of the initial node.</param>
            <param name="minNodeSize">Nodes will stop splitting if the new nodes would be smaller than this.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.Add(`0,UnityEngine.Vector3)">
            <summary>
            Add an object.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.Remove(`0)">
            <summary>
            Remove an object. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.GetNearby(UnityEngine.Ray,System.Single,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within maxDistance of the specified ray.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.GetNearby(UnityEngine.Vector3,System.Single,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within maxDistance of the specified point.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.DrawAllBounds">
            <summary>
            Draws node boundaries visually for debugging.
            Must be called from OnDrawGizmos externally. See also: DrawAllObjects.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.DrawAllObjects">
            <summary>
            Draws the bounds of all objects in the tree visually for debugging.
            Must be called from OnDrawGizmos externally. See also: DrawAllBounds.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.Grow(UnityEngine.Vector3)">
            <summary>
            Grow the octree to fit in all objects.
            </summary>
            <param name="direction">Direction to grow.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.Shrink">
            <summary>
            Shrink the octree if possible, else leave it the same.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctree`1.GetRootPosIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Used when growing the octree. Works out where the old root node would fit inside a new, larger root node.
            </summary>
            <param name="xDir">X direction of growth. 1 or -1.</param>
            <param name="yDir">Y direction of growth. 1 or -1.</param>
            <param name="zDir">Z direction of growth. 1 or -1.</param>
            <returns>Octant where the root node should be.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.#ctor(System.Single,System.Single,UnityEngine.Vector3)">
            <summary>
            Constructor.
            </summary>
            <param name="baseLengthVal">Length of this node, not taking looseness into account.</param>
            <param name="minSizeVal">Minimum size of nodes in this octree.</param>
            <param name="centerVal">Centre position of this node.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.Add(`0,UnityEngine.Vector3)">
            <summary>
            Add an object.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
            <returns></returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.Remove(`0)">
            <summary>
            Remove an object. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.GetNearby(UnityEngine.Ray@,System.Single@,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within maxDistance of the specified ray.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.GetNearby(UnityEngine.Vector3@,System.Single@,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within maxDistance of the specified point.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.SetChildren(VirtualBeings.Tech.Utils.PointOctreeNode{`0}[])">
            <summary>
            Set the 8 children of this octree.
            </summary>
            <param name="childOctrees">The 8 new child nodes.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.DrawAllBounds(System.Single)">
            <summary>
            Draws node boundaries visually for debugging.
            Must be called from OnDrawGizmos externally. See also: DrawAllObjects.
            </summary>
            <param name="depth">Used for recurcive calls to this method.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.DrawAllObjects">
            <summary>
            Draws the bounds of all objects in the tree visually for debugging.
            Must be called from OnDrawGizmos externally. See also: DrawAllBounds.
            NOTE: marker.tif must be placed in your Unity /Assets/Gizmos subfolder for this to work.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.ShrinkIfPossible(System.Single)">
            <summary>
            We can shrink the octree if:
            - This node is >= double minLength in length
            - All objects in the root node are within one octant
            - This node doesn't have children, or does but 7/8 children are empty
            We can also shrink it if there are no objects left at all!
            </summary>
            <param name="minLength">Minimum dimensions of a node in this octree.</param>
            <returns>The new root, or the existing one if we didn't shrink.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.SetValues(System.Single,System.Single,UnityEngine.Vector3)">
            <summary>
            Set values for this node. 
            </summary>
            <param name="baseLengthVal">Length of this node, not taking looseness into account.</param>
            <param name="minSizeVal">Minimum size of nodes in this octree.</param>
            <param name="centerVal">Centre position of this node.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.SubAdd(`0,UnityEngine.Vector3)">
            <summary>
            Private counterpart to the public Add method.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.Split">
            <summary>
            Splits the octree into eight children.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.Merge">
            <summary>
            Merge all children into this node - the opposite of Split.
            Note: We only have to check one level down since a merge will never happen if the children already have children,
            since THAT won't happen unless there are already too many objects to merge.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.Encapsulates(UnityEngine.Bounds,UnityEngine.Vector3)">
            <summary>
            Checks if outerBounds encapsulates the given point.
            </summary>
            <param name="outerBounds">Outer bounds.</param>
            <param name="point">Point.</param>
            <returns>True if innerBounds is fully encapsulated by outerBounds.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.BestFitChild(UnityEngine.Vector3)">
            <summary>
            Find which child node this object would be most likely to fit in.
            </summary>
            <param name="objPos">The object's position.</param>
            <returns>One of the eight child octants.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.ShouldMerge">
            <summary>
            Checks if there are few enough objects in this node and its children that the children should all be merged into this.
            </summary>
            <returns>True there are less or the same abount of objects in this and its children than numObjectsAllowed.</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PointOctreeNode`1.DistanceToRay(UnityEngine.Ray,UnityEngine.Vector3)">
            <summary>
            Returns the closest distance to the given ray from a point.
            </summary>
            <param name="ray">The ray.</param>
            <param name="point">The point to check distance from the ray.</param>
            <returns>Distance from the point to the closest point of the ray.</returns>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.Pair`2">
            <summary>
            Simple helper class to create pairs of values. Based on the following thread at Stackoverflow:
            http://stackoverflow.com/questions/166089/what-is-c-sharp-analog-of-c-stdpair
            
            NOT named tuple to facilitate future upgrade to .NET 4.x
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ParametricSteering1D">
            <summary>
            Class to smoothly control a value by simulated physics (the parameter changes in terms of velocity and acceleration)
            
            NB: if you ever fix bugs here, remember that there may be similar bugs to be fixed in ParametricSteering1DWrapped
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ParametricSteering1D.CalculateDesiredUrgencyFactor(System.Single,System.Single)">
            <summary>
            This method allows us to calculate the urgency factor needed to reach 'targetValue' in 'duration' seconds,
            *assuming* (currently) that the current velocity is 0. If it is non-zero and already heading towards
            targetValue, then the function overestimates the urgency factor, meaning that the result will be reached too soon.
            
            The math behind this method is surprisingly non-obvious, it took me 3 days to develop with Mathematica.
            I've explained it in detail in a notebook (see KuteEngine\Utils\Mathematica\CalculateDesiredUrgencyFactor.nb).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ParametricSteering1D.PredictValueReachedAtFullDeceleration">
            <summary>
            Checked multiple times - the math here is correct. Some sources to check again:
            https://math.stackexchange.com/questions/233107/finding-minimum-distance-traveled-with-specified-deceleration-from-starting-spee
            http://formulas.tutorvista.com/physics/deceleration-formula.html
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ParametricSteering1D.PredictTimeToAlignmentWithTarget">
            <summary>
            See PredictTimeToAlignmentWithTarget(float targetValue)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ParametricSteering1D.PredictTimeToAlignmentWithTarget(System.Single,System.Single)">
            <summary>
            Predict (with high but not perfect precision) the time it takes to reach targetValue in current state.
            This assumes that acceleration is held constant, which means that urgencyFactor01 would have to be constant.
            </summary>
            <param name="targetValue">which target value to move towards</param>
            <param name="urgencyFactor01">which urgency factor to use</param>
            <returns>predicted time in seconds</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.ParametricSteering1D.UpdateOncePerFrame(System.Single,System.Single)">
            <summary>
            Returns false if difference between target and current is 0 at the beginning of the call.
            NB: deltaTime *must* be non-zero
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.PolyLine">
            <summary>
            Simple container that holds a list of Vec2-objects, interpreted as
            a (non-simple) polyline with two ends, or a (non-simple)
            polygon without holes. Also defines a 'Contains' operation
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PolyLine.Points">
            <summary>
            The main data structure of the PolyLine class:
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PolyLine.Closed">
            <summary>
            If true, there is an implied edge between the last and the first point,
            which turns the polyline into a polygon
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PolyLine.Contains(VirtualBeings.Tech.Utils.PolyLine)">
            <summary>
            Function to compute if a polyline is contained in 'this'. Slow, uses O(n^2).
            Assumes that 'this' is a simple, closed polyline with vertices in CCW order.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PolyLine.Contains(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Function to compute if a point is properly contained in 'this'.
            Assumes that 'this' is a simple, closed polyline with vertices in CCW order.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PolyLine.Copy(VirtualBeings.Tech.Utils.PolyLine)">
            <summary>
            Copies other into 'this', doesnt clear 'this' first
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PolyLine.Pop">
            <summary>
            Make PolyLine usable like a stack
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PolyLine.Peek">
            <summary>
            OBS: does *not* check if PolyLine is empty
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.PriorityQueue`2">
             <summary>
             Priority queue based on binary heap,
             Elements with minimum priority dequeued first
            
             NB: there seems to be no good reason to use this variant, use the object-pooled one instead!
             </summary>
             <typeparam name="TPriority">Type of priorities</typeparam>
             <typeparam name="TValue">Type of values</typeparam>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor">
            <summary>
            Initializes a new instance of priority queue with default initial capacity and default priority comparer
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of priority queue with specified initial capacity and default priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with specified initial capacity and specified priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with default initial capacity and specified priority comparer
            </summary>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Initializes a new instance of priority queue with specified data and default priority comparer. O(n).
            </summary>
            <param name="data">data to be inserted into priority queue</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with specified data and specified priority comparer. O(n).
            </summary>
            <param name="data">data to be inserted into priority queue</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.MergeQueues(VirtualBeings.Tech.Utils.PriorityQueue{`0,`1},VirtualBeings.Tech.Utils.PriorityQueue{`0,`1})">
            <summary>
            Merges two priority queues. O(n).
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <returns>resultant priority queue</returns>
            <remarks>
            source priority queues must have equal comparers,
            otherwise <see cref="T:System.InvalidOperationException"/> will be thrown
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.MergeQueues(VirtualBeings.Tech.Utils.PriorityQueue{`0,`1},VirtualBeings.Tech.Utils.PriorityQueue{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Merges two priority queues and sets specified comparer for resultant priority queue. O(n).
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <param name="comparer">comparer for resultant priority queue</param>
            <returns>resultant priority queue</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Enqueue(`0,`1)">
            <summary>
            Enqueues element into priority queue
            </summary>
            <param name="priority">element priority</param>
            <param name="value">element value</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Dequeue">
            <summary>
            Dequeues element with minimum priority and return its priority and value as <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
            <returns>priority and value of the dequeued element</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.DequeueValue">
            <summary>
            Dequeues element with minimum priority and return its value
            </summary>
            <returns>value of the dequeued element</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Peek">
            <summary>
            Returns priority and value of the element with minimun priority, without removing it from the queue
            </summary>
            <returns>priority and value of the element with minimum priority</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.PeekValue">
            <summary>
            Returns value of the element with minimun priority, without removing it from the queue
            </summary>
            <returns>value of the element with minimum priority</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueue`2.IsEmpty">
            <summary>
            Gets whether priority queue is empty
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Enqueus element into priority queue
            </summary>
            <param name="item">element to add</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the priority queue contains a specific element
            </summary>
            <param name="item">The object to locate in the priority queue</param>
            <returns><c>true</c> if item is found in the priority queue; otherwise, <c>false.</c> </returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Find(`1)">
            <summary>
            Finds the first occurrence of a KeyValuePair(TPriority, TValue) with Value==item in the priority queue.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueue`2.Count">
            <summary>
            Gets number of elements in the priority queue
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the priority queue to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from the priority queue. The Array must have zero-based indexing. </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <remarks>
            It is not guaranteed that items will be copied in the sorted order.
            </remarks>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueue`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
            <remarks>
            For priority queue this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueue`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific object from the priority queue.
            </summary>
            <param name="item">The object to remove from the ICollection (Of (T )). </param>
            <returns><c>true</c> if item was successfully removed from the priority queue.
            This method returns false if item is not found in the collection. </returns>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2">
             <summary>
             Priority queue based on binary heap,
             Elements with minimum priority dequeued first.
            
             This version uses object pooling of its *internal* data structure (Pair(T,U)).
             </summary>
             <typeparam name="TPriority">Type of priorities</typeparam>
             <typeparam name="TValue">Type of values</typeparam>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor">
            <summary>
            Initializes a new instance of priority queue with default initial capacity and default priority comparer
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of priority queue with specified initial capacity and default priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with specified initial capacity and specified priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with default initial capacity and specified priority comparer
            </summary>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor(System.Collections.Generic.IEnumerable{VirtualBeings.Tech.Utils.Pair{`0,`1}})">
            <summary>
            Initializes a new instance of priority queue with specified data and default priority comparer. O(n).
            </summary>
            <param name="data">data to be inserted into priority queue</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.#ctor(System.Collections.Generic.IEnumerable{VirtualBeings.Tech.Utils.Pair{`0,`1}},System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of priority queue with specified data and specified priority comparer. O(n).
            </summary>
            <param name="data">data to be inserted into priority queue</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.MergeQueues(VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling{`0,`1},VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling{`0,`1})">
            <summary>
            Merges two priority queues. O(n).
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <returns>resultant priority queue</returns>
            <remarks>
            source priority queues must have equal comparers,
            otherwise <see cref="T:System.InvalidOperationException"/> will be thrown
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.MergeQueues(VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling{`0,`1},VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Merges two priority queues and sets specified comparer for resultant priority queue. O(n).
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <param name="comparer">comparer for resultant priority queue</param>
            <returns>resultant priority queue</returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.Enqueue(`0,`1)">
            <summary>
            Enqueues element into priority queue
            </summary>
            <param name="priority">element priority</param>
            <param name="value">element value</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.DequeueValue">
            <summary>
            Dequeues element with minimum priority and return its value
            </summary>
            <returns>value of the dequeued element</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.PeekKey">
            <summary>
            Returns priority of the element with minimun priority, without removing it from the queue
            </summary>
            <returns>priority and value of the element with minimum priority</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.PeekValue">
            <summary>
            Returns value of the element with minimun priority, without removing it from the queue
            </summary>
            <returns>value of the element with minimum priority</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.IsEmpty">
            <summary>
            Gets whether priority queue is empty
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.Contains(VirtualBeings.Tech.Utils.Pair{`0,`1})">
            <summary>
            Determines whether the priority queue contains a specific element
            </summary>
            <param name="item">The object to locate in the priority queue</param>
            <returns><c>true</c> if item is found in the priority queue; otherwise, <c>false.</c> </returns>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.Find(`1)">
             <summary>
             Finds the first occurrence of a Pair(TPriority, TValue) with Value==item in the priority queue.
            
             NB: creates garbage, not for production use.
             </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.Count">
            <summary>
            Gets number of elements in the priority queue
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.CopyTo(VirtualBeings.Tech.Utils.Pair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the priority queue to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from the priority queue. The Array must have zero-based indexing. </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <remarks>
            It is not guaranteed that items will be copied in the sorted order.
            </remarks>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
            <remarks>
            For priority queue this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.PriorityQueueWithObjectPooling`2.RemoveByValue(`1)">
            <summary>
            Removes the first occurrence of a specific object from the priority queue.
            </summary>
            <param name="item">The object to remove from the ICollection (Of (T )). </param>
            <returns><c>true</c> if item was successfully removed from the priority queue.
            This method returns false if item is not found in the collection. </returns>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.Set`1">
            <summary>
            Simple but generic implementation of a Set, based on a non-generic version by a person called 'Norfy'.
            Based on .Net 2.0's Dictionary(T) class.
            
            Why this class, rather than HashSet? Because HashSet does not have an indexer. The mighty .net overlords allow
            you to iterate over HashSet, but you have to call GetEnumerator(), which generates garbage.
            </summary>
        </member>
        <member name="P:VirtualBeings.Tech.Utils.Set`1.TheDictionary">
            <summary>
            TODO: This is currently a hack to avoid heap allocations (hence garbage): 
            by using the ugly syntax "foreach (KeyValuePair(T, object) kvp in set.TheDictionary) { ... }",
            we can iterate over the set without generating garbage. Of course it would be better to encapsulate
            this into an allocation-free enumerator, as explained here:
            http://stackoverflow.com/questions/5486654/allowing-iteration-without-generating-any-garbage
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Set`1.Add(`0)">
            <summary>
            Add is generally an O(1) operation,
            https://msdn.microsoft.com/en-us/library/bb338565.aspx
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Set`1.Contains(`0)">
            <summary>
            Contains approximates an O(1) operation,
            https://msdn.microsoft.com/en-us/library/bb339987.aspx
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Set`1.Remove(`0)">
            <summary>
            Remove approximates an O(1) operation,
            https://msdn.microsoft.com/en-us/library/bb356469.aspx
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.StackWithRemove`1">
            <summary>
            Simple but generic implementation of a Stack that support removing items at arbitrary position, and peeking.
            Uses a generic List.
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.ListExtensions">
            <summary>
            TODO explain
            </summary>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.Vec2">
            <summary>
            2D-vector class that also contains most of the purely geometric algorithms
            needed for the DCDTriangulation.
            
            The most important resources for writing the Vec2 class have been
            mathworld.wolfram.com, math.stackexchange.com and stackoverflow.com.
            
            Another helpful source of tips on how to solve geometric problems in a robust
            manner is Skiena's "The Algorithm Design Manual", 2nd ed. 2008.
            Another is, of course, O'Rourke, "Computational Geometry in C", 1998 (which
            I use almost never, instead relying on the script of the comp. geom. course I
            took at FernUni Hagen).
            
            The following class does make some minor-though-non-trivial research contributions
            (e.g., GetPointOnSegmentThatMinimizesDistanceToTwoPoints())
            
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Normalize">
            <summary>
             Normalize Vec2, i.e., set its magnitude to 1 (or generate exception if it is currently 0).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Rotate90">
            <summary>
             Rotate Vec2 by 90 degrees CCW.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.RotateMinus90">
            <summary>
             Rotate Vec2 by 90 degrees CW.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.RotateRad(System.Double)">
            <summary>
             Rotate Vec2 by rad degrees CCW. Calls Math.Sin and Math.Cos, so use with care.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.RotateRadAround(VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
             Rotate Vec2 by rad degrees CCW around pivot.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.ClampMagnitude(System.Double)">
            <summary>
            Clamp the magnitude of a Vec2.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Lerp(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Simple linear interpolation function; robust.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Angle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate angle abc in radians via law of Cosine. Nonrobust: assumes A =/= B, B =/= C.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Angle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate angle ac in radians via law of Cosine. Nonrobust: assumes A =/= 0, C =/= 0.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.SignedAngleInDegs(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Signed version of Vec2.Angle, result converted to degrees (positive means B is right of A, negative means left)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Dist(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate Euclidian distance between this and other. Expensive (uses Sqrt).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistSqrd(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate square of Euclidian distance between this and other. Cheap.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsCloseToPoint(VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Test if distance between 'this' point and other is smaller than epsilon.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsCloseToSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,System.Double@,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Test if distance between 'this' point and a segment with endpoints v1,v2 is
            smaller than epsilon. *If* this is the case, save the projection of this onto
            the edge in pProjection (since we get it for free anyway). Assumes v1 != v2.
            Note that calculation of e-closeness is imprecise (see code).
            
            For info on the math, see http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html
            and my Mathematica notebook "Point_on_line_projection.nb".
            In contrast to the mathworld article, I do not use Abs(.) in the calculation, as I need
            the distance to be signed. The sign of the distance also had to be reversed.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsCloseToSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Simpler access to IsCloseToSegment(Vec2, Vec2, double, out double, out Vec2)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsCloseToEdge(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Is 'this' Epsilon-close to the line going through vertices v1, v2 (with v1 != v2)?
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToEdge(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Simple helper to calculate distance of 'this' to the *line* defined by v1v2. Assumes v1 != v2.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToEdgeSqrd(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Simple helper to calculate squared distance of 'this' to the line defined by v1v2. Assumes v1 != v2.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate distance of 'this' to the segment vw (*not* just the line through vw).
            This short and robust solution is by 'Grumdrig', see 
            http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToSegmentSqrd(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Squared (hence faster) version of DistToSegment()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.ClosestPointOnSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Calculate point s on segment s1s2 that minimizes the distance p->s.
            Modeled on DistToSegmentSqrd()
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.SegmentSegmentDist(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Calculate length of a shortest segment between segments ab and vw. Robust.
            NB: Such a segment starts at one of the four vertices a, b, v, w.
            We can therefore use DistToSegmentSqrd() four times, and take the minimum.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.ProjectOntoLine(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Return projection of the current vertex onto the line through v and w. Compare DistToSegment().
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.ProjectOntoVector(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Return projection of the current vector onto v. Fast.
            See https://en.wikipedia.org/wiki/Vector_projection#Vector_projection_2
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.GetPointOnSegmentThatMinimizesDistanceToTwoPoints(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Calculate point p on segment s1s2 that minimizes the combined distance p->p1 + p->p2.
            If s1s2 and p1p2 are collinear, this point may not be unique, in which case we return
            one of {s1, s2, (s1 + s2)/2}.
            If the segments are not parallel, the unique point can be s1, s2, or a point on s1s2.
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="Epsilon">Should be large enough to be meaningfully squareable. Specifies the distance below which
            two points (like s1, s2) can be considered identical.</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.GetSubSegmentInsidePlaneSector(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2@,VirtualBeings.Tech.Utils.Vec2@)">
            <summary>
            Return the endpoints of the subsegment of segmentLeft-segmentRight which are both right of sectorLeftSide and left of sectorRightSide.
            Does not try to be numerically robust when segment endpoints are on/near the sector borders etc.
            
            The plane sector must have an angle of less than Pi.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.GetCircleLineIntersections(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,VirtualBeings.Tech.Utils.Vec2@,VirtualBeings.Tech.Utils.Vec2@,System.Double)">
            <summary>
            Calculate circle/line intersections, as explained by: http://mathworld.wolfram.com/Circle-LineIntersection.html
            If no intersection exists, i1 will be set to invalid; if only one exists (or the two are epsilon-close), i2 will be set to invalid.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToTriangleBorder(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Simple helper to calculate the minimum distance between 'this' and the border of the
            triangle defined by t1-t3.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.DistToTriangleBorderSqrd(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Like DistToTriangleBorder, but squared
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.GetClosestPointOnTriangleBorder(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Return the point on triangle border that's closest to 'this'
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInCircle_Precise(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Fast point-in-circle test by Jonathan Richard Shewchuk; v1-v3 must be in -=*CLOCKWISE*=- order.
            This is a non-robust, which means that it may return either true or false if 'this' and v1-v3
            are cocircular. For the purposes pursued here, this is ok and dealt with at a higher level.
            See http://www.cs.cmu.edu/~quake/robust.html, especially the file
            precision.c (public-domain license) which is available from that site.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInCircle_Naive(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Boolean)">
            <summary>
            My own version of the IsInCircle test, for testing purposes. Based on formulae from
            http://mathforum.org/library/drmath/view/55239.html and derivations in Mathematica,
            see my Mathematica notebook IsInCircle_derivation.nb.
            This test is easier to understand than Shewchuk's, but the two are not mathematically
            equivalent (and this one doesn't require v1-v3 to be ordered CW/CCW).
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInTriangle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Standard point-in/on-triangle test: check if pt is in/on the intersection of
            the three half-planes defined by v1-v3. E.g., see
            http://freelancersunite.net/software/point-triangle-testing/
            Makes no assumption about CW or CCW orientation.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInConvexPolygon(System.Collections.Generic.IEnumerable{VirtualBeings.Tech.Utils.Vec2},System.Int32)">
            <summary>
            Check if 'this' is inside the convex polygon defined by 'pts'. Parameter
            'nPts' must provide the number of points in 'pts'. Parameter 'pts' can
            describe the polygon either in CW or in CCW order.
            
            TODO should not use IEnumerable(T)
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInConvexQuadrilateral(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Check if 'this' lies properly in the convex quadrilateral ABCD, which
            can be defined CW or CCW. This is NOT a numerically robust test.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInConvexQuadrilateral_WithEpsilon(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Check if 'this' lies in, or Epsilon-close to, the convex quadrilateral ABCD, which
            can be defined CW or CCW.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsSegmentCrossingConvexQuadrilateral(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Determine if any part of the line segment v1v2 lies in the convex quadrilateral ABCD,
            which can be defined in CW or CCW order.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsDegenerateTriangle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Determine if points v1-v3 do NOT form a valid triangle. NB: this happens not only
            when they are collinear, but also when they are neither collinear nor triangular
            due to numerical errors. Both cases are recognized.
            
            Default value for minArea is based on empirical tests - 1E-14 was too small. But it
            may have to be adjusted if points are generally very close/far.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.PolygonArea(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2})">
            <summary>
            Fast method for calculating the area of a simple polygon without holes.
            NB: pts must contain the vertices of the polygon in CCW order.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.CentroidOfTriangle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculates the centroid of a triangle, see Wikipedia. In contrast to incenter,
            the calculation is very rapid, and the centroid (like the incenter) is guaranteed to
            be within the bounds of the triangle.
            NB: does not check if the triangle is degenerate.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IncenterOfTriangle(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculates the incenter of a triangle, see http://mathworld.wolfram.com/Incenter.html.
            The incenter has the nice property of being at a location to
            which there is a perpendicular line from each of the three sides
            of the triangle. In a triangulation, the incenters of two adjacent triangles can
            therefore be connected by a line that does not cross any other triangle.
            NB: does not check if the triangle is degenerate.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInSector(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Standard point-in/on-sector test: check if pt is on/left of vCv1 *and*
            on/right of vCv2. See IsInTriangle.
            NB: sector angle must be equal or smaller than Pi.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IntersectsWithSector(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Determine if the segment defined by s1-s2 intersects with the circle sector
            defined by center, sectorLeftSide and sectorRightSide. The sector must have an angle equal to or less than Pi.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Sign(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Check which side of a halfplane (or vector v1->v2) this vertex is on.
             1: left,
            -1: right,
             0: 'this' is on the line that goes through v1->v2
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Sign(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Check which side of a halfplane (or vector v) this vertex is on.
             1: left,
            -1: right,
             0: 'this' is on vector v
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.SignNonZero(VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Like int Sign(Vec2 v), but this version returns:
             1: if 'this' is left of or on vector v,
            -1: otherwise
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.LineEquation(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Helper function: get the second coordinate of a point on a line that is 
            defined by two points; use point-slope equation.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.HasProperIntersection(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Fast test that determines if line *segments* AB and CD *properly* intersect. Explanations
            can be found at several places on the net; the idea is that an intersection exists if
            A, B are on opposite sides of CD and C, D on opposite sides of AB.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.HasProperIntersection_LineAndSegment(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Like HasProperIntersection(), but here, AB is interpreted as a line rather than a segment.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.HasIntersection_ProperOrImproper(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Test that determines if line segments AB and CD intersect, even improperly.
            Extends the test from HasProperIntersection() with four calls to DistToSegmentSqrd().
            Significantly slower.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.CCW(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Check if v1-v3 are in CCW order. Returns false if the three are collinear or if two of
            the three are identical.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsInBoundingBox_Epsilon(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double)">
            <summary>
            Fast test that determines if 'this' is within the AABB defined by points A and B.
            No assumptions are made about A and B's position.
            
            Epsilon should be non-zero because AB could be a horizontal/vertical line segment.
            Epsilon has the effect of slightly increasing the size of the bb.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.SetFromIntersectionPoint_Nonrobust(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Calculate the intersection point of line segments v1v2 and v3v4.
            Set 'this' to the intersection point and return true if it is on both
            segments, otherwise return false.
            
            WARNING: for numerical reasons, the function will not find an intersection
            point if three of the four vertices form a degenerate triangle.
            This is easy to fix, if you would like the function to calculate an
            intersection even in such a case.
            
            Adapted from an excellent tutorial by 'lbackstrom' at
            http://www.ucancode.net/faq/C-Line-Intersection-2D-drawing.htm
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.CalculateIntersectionPoint(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,System.Boolean)">
            <summary>
            Calculate the intersection point of lines v1v2 and v3v4. Caller should
            only use this function if they are sure the intersection point _should_
            exist (that is, v1 != v2, v3 != v4, and the segments are not truly parallel).
            
            If invalidOK is false and v1v2 and v3v4 are pseudoparallel (for numerical reasons), we
            return the midpoint of v3v4!
            
            Adapted from an excellent tutorial by 'lbackstrom' at
            http://www.ucancode.net/faq/C-Line-Intersection-2D-drawing.htm
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsConvexCounterclockwiseQuadrilateral(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Use four half-plane tests to determine if v1-v4 is a convex quadrilateral. Points
            must be in CCW order.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.TangentPoint(VirtualBeings.Tech.Utils.Vec2,System.Double,System.Boolean)">
            <summary>
            Return a tangent point of the half-line that goes through 'this' and passes 'to' at
            a distance of 'radius'. If radius is zero or (this - from).Magnitude is less than radius, return invalid Vec2.
            If bLeft is true, return the tangent point that lies to the left of vector from-to.
            
            Based on: http://stackoverflow.com/questions/1351746/find-a-tangent-point-on-circle  and  http://jsfiddle.net/zxqCw/1/
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.TangentPointsOfTwoCircles(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Double,System.Double,System.Boolean,System.Boolean,VirtualBeings.Tech.Utils.Vec2@,VirtualBeings.Tech.Utils.Vec2@,System.Double)">
            <summary>
            General-purpose function for calculating tangent points of a tangent line of two arbitrary circles (if it exists).
            The concept is explained at http://en.wikipedia.org/wiki/Tangent_lines_to_circles#Tangent_lines_to_two_circles
            In the direction center1->center2, the caller specifies on which side the two tangent points have to lie.
            If the sides are identical, the caller is requesting outer tangents, otherwise inner tangents.
            Epsilon specifies an acceptable margin for numerical errors.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.ThirdPointOfRightTriangle(VirtualBeings.Tech.Utils.Vec2,System.Double,System.Boolean)">
            <summary>
            For right triangle ACB with right angle ACB, in which points A ('this') and B and the length of oppposite leg BC
            are known, this function calculates the position of the third vertex C. If bLeft is true, C will lie left
            to the vector A->B, otherwise on its right.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.PointInPolygonTest(System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2})">
            <summary>
            Standard point-in-polygon test. Adapted from code by Daniel Kuppitz, for an explanation see
            http://conceptual-misfire.awardspace.com/point_in_polygon.htm
            
            TODO: *BUGGY*, ended up not needing + thoroughly testing it, usage deprecated.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.Area2(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            From O'Rourke, calculates 2 * signed area of a triangle. Sign will be
            positive if abc are in CCW order, negative otherwise.
            </summary>
            <param name="a">Point on 'anchor' segment</param>
            <param name="b">Point on 'anchor' segment</param>
            <param name="c">Additional point</param>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.Vec2.IsOnLeft_Area2(VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2)">
            <summary>
            Three uses of O'Rourke's TriArea() function
            </summary>
            <param name="a">Point on 'anchor' segment</param>
            <param name="b">Point on 'anchor' segment</param>
            <param name="c">Evaluated point</param>
        </member>
        <member name="T:VirtualBeings.Tech.Utils.RadialSort">
            <summary>
            Sort a collection of Vec2s radially around vCenter, where the vector vCenter->vRadialOriginMarker
            marks the origin of the coordinate system.
            OBS: if a and b are collinear from vCenter, they are considered 'equal'.
            </summary>
        </member>
        <member name="M:VirtualBeings.Tech.Utils.RadialSort.SortPoints(VirtualBeings.Tech.Utils.Set{VirtualBeings.Tech.Utils.Vec2},System.Collections.Generic.List{VirtualBeings.Tech.Utils.Vec2},VirtualBeings.Tech.Utils.Vec2,VirtualBeings.Tech.Utils.Vec2,System.Boolean)">
            <summary>Function that performs a radial sort</summary>
            <param name="setPoints">The collection of points to be sorted</param>
            <param name="lResultBuffer"></param>
            <param name="vCenter">The radial center for the sorting</param>
            <param name="vRadialOriginMarker">A point (!= vCenter) that marks the origin for the sorting comparisons.
            You can picture vRadialOriginMarker as the point that marks "12" on a (rotated) clock, so that
            the algorithm knows that "11:55" is *larger* than "12:03" etc.</param>
            <param name="CCW">True means that the points will be sorted in counter-clockwise order</param>
            <returns>A new collection with the sorted Vec2s</returns>
        </member>
        <member name="M:VirtualBeings.BehaviorComposition.Face.#ctor(VirtualBeings.Tech.BehaviorComposition.Activity)">
            <summary>
            The parent activity need to have a Look Service Activity
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:VirtualBeings.BehaviorComposition.Idle">
            <summary>
            Generic Idle functionnality that make the being feel alive without doing anything
            </summary>
        </member>
        <member name="M:VirtualBeings.BehaviorComposition.Locomotion.MoveTo(VirtualBeings.Tech.BehaviorComposition.IRS,System.Func{UnityEngine.Vector3},System.Nullable{System.Single},System.Int32)">
             <summary>
            
             </summary>
             <param name="targetRS"></param>
             <param name="goal"></param>
             <param name="overrideArrivalDistance">If overriden, the arrival distance wont reset to previous value, it is kept this way until new override</param>
             <param name="variationIndex">Value between 0 and 5 (included) to specify the walk variation to use></param>
        </member>
        <member name="M:VirtualBeings.BehaviorComposition.Locomotion.RequestST(VirtualBeings.Tech.BehaviorComposition.IST,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request transition to ST (self transition). Note that unlike RS, ST are (1) not guarranteed and
            (2) interruptible by another ST request or a RS change request
            </summary>
        </member>
        <member name="M:VirtualBeings.BehaviorComposition.Locomotion.SetTargetRS(VirtualBeings.Tech.BehaviorComposition.IRS,VirtualBeings.Tech.BehaviorComposition.ITransitionType,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Request new RS (root state); unless overridden by another request (or this behavior looses control),
            it is guaranteed that this change is eventually successful.
            NB: transition type needs to be set procedurally for now.
            </summary>
            <param name="targetRS"></param>
            <param name="transitionType">Note that this may be overriden if a functional TransitionType is needed
            to leave/arrive at an angle etc.</param>
            <param name="transitionSpeed01"></param>
            <param name="transitionIntensity01"></param>
            <param name="transitionLeftRight"></param>
            <param name="transitionParameterA"></param>
            <param name="transitionParameterB"></param>
        </member>
        <member name="T:VirtualBeings.Beings.Floater.Infrastructure.RSFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of RSFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Beings.Floater.Infrastructure.STFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of STFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Beings.Floater.Infrastructure.TransitionTypeFloaterBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of TransitionTypeFloater as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Beings.Humanoid.USTHumanoidBase">
             <summary>
             Marker ABC known by KuteEngine to ensure type-safe use of STHumanoid as an ExtensibleEnum
             by clients of the Rascal server
            
             PS: superclass ExtensibleEnum(T) keeps track of the 'enum' classes that instantiate this class.
             This means that it's not possible to further generalize it into a superclass that works for cats, birds and so on.
             </summary>
        </member>
        <member name="T:VirtualBeings.Installer.BeingInstaller">
            <summary>
            Manage all KuteEngine's component : Instantiation and Initialization, and handle all of their's dependency.
            <br/> Must be called before everything else when using KuteEngine. <br/>
            Should be placed on a GameObject that is placed on a scene where Beings are spawned.
            </summary>
        </member>
        <member name="M:VirtualBeings.Installer.BeingInstaller.Initialize">
            <summary>
            Initialize this Installer, that handle all the instantiation and initialization of every KuteEngine's component. <br/>
            Should be called before Unity script using script order.
            </summary>
        </member>
        <member name="T:VirtualBeings.Installer.BeingInstallerSettings">
            <summary>
            Contains all the settings of every KuteEngine's component.
            Used for there initializations.
            </summary>
        </member>
        <member name="T:VirtualBeings.UnityIntegration.Service.PackageInstaller">
            <summary>
            TODO(RAPH) : Create a Package installer for reach being package to import virtual being tech automatically (and controller package too)
            </summary>
        </member>
        <member name="F:VirtualBeings.UnityIntegration.VirtualBeingsSettings.Key">
            <summary>
            Key that define the subscription model.
            </summary>
        </member>
        <member name="T:VirtualBeings.UnityIntegration.VirtualBeingsSettings.SubscriptionData">
            <summary>
            For a given Key, define the max number of MainCharacter, SideCharacter and BackgroundCharacter during a Session.
            </summary>
        </member>
    </members>
</doc>
